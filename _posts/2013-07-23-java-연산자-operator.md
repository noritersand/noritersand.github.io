---
layout: post
date: 2013-07-23 03:47:00 +0900
title: '[Java] 연산자 Operator'
categories:
  - java
tags:
  - java
  - operator
---

* Kramdown table of contents
{:toc .toc}

## 용어

- 연산자(Operator): 어떠한 기능을 수행하는 기호
- 피연산자(Operand): 연산자의 작업 대상

## 연산자의 종류

- 단항 연산자: `+`, `-`, `(type)`, `++`, `--`, `~`, `!`
- 이항 산술 연산자: `+`, `-`, `*`, `/`, `%`, `<<`, `>>`, `>>>`
- 이항 비교 연산자: `>`, `<`, `>=`, `<=`, `==`, `!=`
- 이항 논리 연산자: `&&`, `||`, `&`, `^`, `|`
- 삼항 연산자: `? :`
- 대입 연산자: `=`, `operator=`

## 연산자 우선순위

- 괄호의 우선순위가 가장 높음
- 산술 > 비교 > 논리 > 대입
- 단항 > 이항 > 삼항
- 연산자의 연산 진행방향은 왼쪽에서 오른쪽
- 단항, 대입 연산자는 오른쪽에서 왼쪽

![](/images/java-operator-1.png)

## 단항 연산자 ++ --

- `++`: 증가 연산자. 피연산자의 값 +1
- `--`: 감소 연산자. 피연산자의 값 -1

연산자의 위치에 따라 연산 우선순위가 바뀌게 되니 주의할 것.

```java
int n = 1;

int value = n++;
System.out.println(value); //1

int n = 1;
int value = ++n;
System.out.println(value); //2
```

## 논리 부정 연산자 !

불리언 타입의 피연산자를 반대로 바꾼다.

```java
boolean flag = true;
flag = !flag;
System.out.println(flag);

int n = 0;
if (n != 1) {
    System.out.println("1이 아니네?");
}

-> false
-> 1이 아니네?
```

## 비트 전환 연산자 ~

정수를 2진수로 표현했을 때, 1을 0으로 0은 1로 바꾼다. 정수형에서만 사용가능

|  2진수           |  10진수 |
|------------------|---------|
| 00001010         | 10      |
| 11110101         | -11     |
| 11110101<br>00000001 | -11<br>+) 1 |
| 11110110         | -10     |

```java
int binary = 0b1111; // 15, 2진수 리터럴(b)
int octal = 011; // 9, 8진수 리터럴
int hexaDecimal = 0xE; // 14, 16진수 리터럴(x)

System.out.println(~binary); // -16
System.out.println(~octal); // -10
System.out.println(~hexaDecimal); // -15

System.out.println(~100); // -101
```

## 비트 시프트 연산자 << >> >>>

비트를 이동하는 연산자. `2n` 으로 곱하거나 나눈 결과와 같으며 곱셈, 나눗셈보다 연산속도가 빠르다.

- `x << n`: (x * 2ⁿ과 같음)
- `x >> n`: (x / 2ⁿ과 같음)

```java
System.out.println(8 << 2); // 8 * (2 ^ 2) = 32
System.out.println(8 >> 2); // 8 / (2 ^ 2) = 2
```

2진법으로 설명하는게 더 쉽다.

### <<, left shift operator

`x`의 비트를 `n` 만큼 왼쪽으로 이동하면서 새로운 자리는 0으로 채운다:

```java
int a = 9; // 1001
a << 2;    // 100100
```

### >>, right shift operator

`x`의 비트를 오른쪽으로 이동하면서 새로운 자리는 `x`가 양수일 때 0으로, 음수일 땐 1로 채운다:

```java
int a = 9; // 1001
a >> 2;    // 0010, 10진수로 2

int b = -9; // 11111111111111111111111111110111
a >> 2;     // 11111111111111111111111111111101, 10진수로 -3
```

### >>>, unsigned right shift operator

`x`의 비트를 오른쪽으로 이동하면서 새로운 자리는 0으로 채운다.:

```java
int a = 9; // 1001
a >>> 2;   // 0010, 10진수로 2

int b = -9; // 11111111111111111111111110011100
b >>> 2;    // 00111111111111111111111111111101, 10진수로 1073741821
```

`x`가 양수인지 음수인지는 판단하지 않으며 양의 정수에 한해 `>>` 연산자와 결과가 같다.  
최상위 비트는 부호를 위한 자리인데 이 자리까지 0으로 채워버린다. 때문에 `x`가 음수인 경우 `>>>` 연산 후 양수로 바뀌는 특징이 있음.

## 비트 연산자 | & ^

피연산자를 비트단위로 연산한다. 실수형을 제외한 모든 기본형에 사용가능

- `|`: OR 연산자. 피연산자 중 어느 한 쪽이 1이면 1
- `&`: AND 연산자. 피연산자 양 쪽 모두 1이면 1
- `^`: XOR 연산자. 피연산자가 서로 다를 때 1

| x | y | x \| y | x & y | x ^ y |
|---|---|-------|-------|-------|
| 1 | 1 | 1     | 1     | 0     |
| 1 | 0 | 1     | 0     | 1     |
| 0 | 1 | 1     | 0     | 1     |
| 0 | 0 | 0     | 0     | 0     |

| 식              | 2진수                          | 10진수 |
|-----------------|--------------------------------|--------|
| 3 \| 5 = 7       | 00000011<br>00000101 | 3<br>5     |
|                  |00000111 | 7                              |
| 3 & 5 = 1       | 00000011<br>00000101 | 3<br>5     |
|                 | 00000001 | 1                              |
| 3 ^ 5 = 6       | 00000011<br>00000101 | 3<br>5     |
|                 | 00000110 | 6                              |
