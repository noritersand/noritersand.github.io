{"meta":{"title":"내 아이큐 80, 너도 80, 둘이 합쳐 160","subtitle":null,"description":"놀이터흙이제맛의 블로그","author":"놀이터흙이제맛","url":"http://noritersand.github.io"},"pages":[{"title":"","date":"2018-07-11T00:15:13.217Z","updated":"2018-07-11T00:15:13.217Z","comments":true,"path":"about/index.html","permalink":"http://noritersand.github.io/about/index.html","excerpt":"","text":"hello!"}],"posts":[{"title":"코드모음-Java: 파일명 일괄 변경","slug":"코드모음-Java-파일명-일괄-변경","date":"2018-07-16T00:36:25.000Z","updated":"2018-07-16T00:37:15.349Z","comments":true,"path":"코드모음/코드모음-Java-파일명-일괄-변경/","link":"","permalink":"http://noritersand.github.io/코드모음/코드모음-Java-파일명-일괄-변경/","excerpt":"","text":"required JDK8 or higher import java.io.File;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.StandardCopyOption;import java.util.stream.Stream;public class ReplaceFileName &#123; private static final String targetLocation = \"c:/temp\"; private static final String prefix = \"02-alarm-\"; private static final String suffix = \"\"; private static final String destLocation = \"c:/dest\"; public static void main(String[] args) throws Exception &#123; Path path = new File(targetLocation).toPath(); Stream&lt;Path&gt; list = Files.list(path); // list.forEach(System.out::println); list.forEach((k) -&gt; &#123; final String fileName = k.toString(); final String newFileName = prefix + fileName.substring(fileName.lastIndexOf(File.separator) + 1, fileName.length()) + suffix; Path newPath = new File(destLocation, newFileName).toPath(); try &#123; Files.move(k, newPath, StandardCopyOption.REPLACE_EXISTING); &#125; catch (IOException e) &#123; System.err.println(e); &#125; &#125;); list.close(); &#125;&#125;","categories":[{"name":"코드모음","slug":"코드모음","permalink":"http://noritersand.github.io/categories/코드모음/"}],"tags":[{"name":"java","slug":"java","permalink":"http://noritersand.github.io/tags/java/"},{"name":"lambda","slug":"lambda","permalink":"http://noritersand.github.io/tags/lambda/"},{"name":"JDK8","slug":"JDK8","permalink":"http://noritersand.github.io/tags/JDK8/"},{"name":"stream","slug":"stream","permalink":"http://noritersand.github.io/tags/stream/"},{"name":"file","slug":"file","permalink":"http://noritersand.github.io/tags/file/"}]},{"title":"Java: 특정 폴더의 모든 파일명 변경","slug":"Java-특정-폴더의-모든-파일명-변경","date":"2018-07-16T00:12:51.000Z","updated":"2018-07-16T00:28:37.897Z","comments":true,"path":"코드모음/Java-특정-폴더의-모든-파일명-변경/","link":"","permalink":"http://noritersand.github.io/코드모음/Java-특정-폴더의-모든-파일명-변경/","excerpt":"","text":"required JDK8 or higher import java.io.File;import java.io.IOException;import java.nio.file.Files;import java.nio.file.Path;import java.nio.file.StandardCopyOption;import java.util.stream.Stream;public class ReplaceFileName &#123; private static final String targetLocation = \"c:/temp\"; private static final String prefix = \"02-alarm-\"; private static final String suffix = \"\"; private static final String destLocation = \"c:/dest\"; public static void main(String[] args) throws Exception &#123; Path path = new File(targetLocation).toPath(); Stream&lt;Path&gt; list = Files.list(path); // list.forEach(System.out::println); list.forEach((k) -&gt; &#123; final String fileName = k.toString(); final String newFileName = prefix + fileName.substring(fileName.lastIndexOf(File.separator) + 1, fileName.length()) + suffix; Path newPath = new File(destLocation, newFileName).toPath(); try &#123; Files.move(k, newPath, StandardCopyOption.REPLACE_EXISTING); &#125; catch (IOException e) &#123; System.err.println(e); &#125; &#125;); list.close(); &#125;&#125;","categories":[{"name":"코드모음","slug":"코드모음","permalink":"http://noritersand.github.io/categories/코드모음/"}],"tags":[{"name":"java","slug":"java","permalink":"http://noritersand.github.io/tags/java/"},{"name":"lambda","slug":"lambda","permalink":"http://noritersand.github.io/tags/lambda/"},{"name":"JDK8","slug":"JDK8","permalink":"http://noritersand.github.io/tags/JDK8/"},{"name":"stream","slug":"stream","permalink":"http://noritersand.github.io/tags/stream/"}]},{"title":"JavaScript: continuation-passing style","slug":"JavaScript-continuation-passing-style","date":"2018-07-06T08:52:58.000Z","updated":"2018-07-11T00:15:13.192Z","comments":true,"path":"javascript/JavaScript-continuation-passing-style/","link":"","permalink":"http://noritersand.github.io/javascript/JavaScript-continuation-passing-style/","excerpt":"","text":"원문: http://matt.might.net/articles/by-example-continuation-passing-style/한글번역: http://dogfeet.github.io/articles/2012/by-example-continuation-passing-style-in-javascript.html","categories":[{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/categories/javascript/"}],"tags":[{"name":"ecmascript","slug":"ecmascript","permalink":"http://noritersand.github.io/tags/ecmascript/"},{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/tags/javascript/"},{"name":"cps","slug":"cps","permalink":"http://noritersand.github.io/tags/cps/"},{"name":"continuation passing style","slug":"continuation-passing-style","permalink":"http://noritersand.github.io/tags/continuation-passing-style/"}]},{"title":"Git: 윈도우에 Git 서버 설치하기","slug":"Git-윈도우에-Git-서버-설치하기","date":"2018-07-06T08:45:19.000Z","updated":"2018-07-11T00:15:13.188Z","comments":true,"path":"git/Git-윈도우에-Git-서버-설치하기/","link":"","permalink":"http://noritersand.github.io/git/Git-윈도우에-Git-서버-설치하기/","excerpt":"","text":"참고한 글 http://gitblit.com/ http://www.lesstif.com/pages/viewpage.action?pageId=26084460 git 서버 설치/구동http://www.lesstif.com/pages/viewpage.action?pageId=26084460위 링크 참고. (한 줄 요약: jetty가 내장된 gitblit으로 git 서버 구동.) JCE 설치오라클에서 다운받은 압축파일을 풀면 jar파일이 몇개 있는데 요것들을 java설치경로/lib/security 아래에 덮어쓰기 한다. 끗","categories":[{"name":"git","slug":"git","permalink":"http://noritersand.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://noritersand.github.io/tags/git/"},{"name":"gitblit","slug":"gitblit","permalink":"http://noritersand.github.io/tags/gitblit/"}]},{"title":"Git: 파일 무시하기 .gitignore","slug":"Git-파일-무시하기-gitignore","date":"2018-07-06T07:59:40.000Z","updated":"2018-07-11T00:15:13.189Z","comments":true,"path":"git/Git-파일-무시하기-gitignore/","link":"","permalink":"http://noritersand.github.io/git/Git-파일-무시하기-gitignore/","excerpt":"","text":"참고한 글 https://git-scm.com/book/ko/v1/Git의-기초-수정하고-저장소에-저장하기#파일-무시하기 .gitignore 파일을 만들고 무시할 파일패턴을 명시하면 패턴에 따라 해당파일을 git이 자동으로 추가하거나 추적하지 않게 된다.*.[oa]*~ 첫번쨰 줄은 확장자가 .o 나 .a인 파일을 Git이 무시하라는 것이고 둘째 줄은 ~로 끝나는 모든 파일을 무시하라는 것이다. Pattern 아무것도 없거나, #으로 시작하는 줄은 무시한다(주석처리 가능). 표준 Glob패턴을 사용한다. 디렉토리는 슬래시(/)를 끝에 사용하는 것으로 표현한다. 느낌표(!)로 시작하는 패턴의 파일은 무시하지 않는다. : 문자가 하나도 없거나 하나 이상 [abc] : a, b, c 중 하나 ? : 문자 하나 [0~9] : 캐릭터 사이에 있는 문자 하나 example# 확장자가 .a인 파일 무시*.a# 윗 라인에서 확장자가 .a인 파일은 무시하게 했지만 lib.a는 무시하지 않음!lib.a# 현재 디렉토리에 있는 TODO파일은 무시하고 subdir/TODO처럼 하위디렉토리에 있는 파일은 무시하지 않음/TODO# build/ 디렉토리에 있는 모든 파일은 무시build/# doc/notes.txt 파일은 무시하고 doc/server/arch.txt 파일은 무시하지 않음doc/*.txt# doc 디렉토리 아래의 모든 .txt 파일을 무시doc/**/*.txt","categories":[{"name":"git","slug":"git","permalink":"http://noritersand.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://noritersand.github.io/tags/git/"},{"name":"gitignore","slug":"gitignore","permalink":"http://noritersand.github.io/tags/gitignore/"}]},{"title":"Git: 로컬 디스크에 원격 저장소 만들기","slug":"Git-로컬-디스크에-원격-저장소-만들기","date":"2018-07-06T07:25:33.000Z","updated":"2018-07-11T00:15:13.187Z","comments":true,"path":"git/Git-로컬-디스크에-원격-저장소-만들기/","link":"","permalink":"http://noritersand.github.io/git/Git-로컬-디스크에-원격-저장소-만들기/","excerpt":"","text":"일반적인 깃 저장소(원격 저장소가 따로 존재하는 로컬 저장소)는 ‘git init’으로 생성하지만 원격(서버) 저장소라면 bare-repository로 생성해야 한다. bare-repository는 워킹 트리가 없고 변경사항만 추적하는 저장소를 말한다. bare로 생성하는 이유는 다음 링크를 참조할 것: http://bit.ly/175mFLh 어쨌거나 bare-repository를 생성해서 원격 저장소로 등록해보자. clone을 이용한 방법$ git init --bareInitialized empty Git repository in c:/Users/fixalot/work/gitserver/$ git clone file://c:/Users/fixalot/work/gitserver myrepositoryCloning into 'myrepository'...warning: You appear to have cloned an empty repository.Checking connectivity... done 여기서는 file 프로토콜을 사용했는데 생략할 수도 있다.$ git clone c:/Users/fixalot/work/gitserver myrepository2Cloning into 'myrepository2'...warning: You appear to have cloned an empty repository.done.$ git clone ~/work/gitserver myrepository3Cloning into 'myrepository3'...warning: You appear to have cloned an empty repository.done. file 프로토콜 사용여부에 따른 차이는 여기에서 확인할 수 있다. remote를 이용한 방법저장소 생성까지는 clone과 같다.$ git init --bareInitialized empty Git repository in c:/Users/fixalot/work/gitserver/ 그리고 다음처럼 깃 저장소 등록 후 서버를 추가한다:$ git initInitialized empty Git repository in c:/Users/fixalot/work/test/.git/$ git remote add origin file://c:/Users/fixalot/work/gitserver$ git remote -vorigin file://c:/Users/fixalot/work/gitserver (fetch)origin file://c:/Users/fixalot/work/gitserver (push) 하지만 이렇게 할 경우 다음과 같은 에러들이 발생할 수 있다:$ git push -u origin mastererror: src refspec master does not match any.error: failed to push some refs to 'file://c:/Users/fixalot/work/gitserver'$ git pull -u origin masterfatal: Couldn't find remote ref masterfatal: The remote end hung up unexpectedly 이건 아무 파일이나 생성 - 커밋 - 푸싱으로 간단하게 해결된다. 뭐야$ touch readme$ git add .$ git commit -m \"init\"[master (root-commit) 1a90f6d] init 1 file changed, 0 insertions(+), 0 deletions(-) create mode 100644 readme$ git push -u origin masterCounting objects: 3, done.Writing objects: 100% (3/3), 198 bytes | 0 bytes/s, done.Total 3 (delta 0), reused 0 (delta 0)To file://c:/Users/fixalot/work/gitserver * [new branch] master -&gt; masterBranch master set up to track remote branch master from origin.$ git pull -u origin masterFrom file://c:/Users/fixalot/work/gitserver * branch master -&gt; FETCH_HEADAlready up-to-date.","categories":[{"name":"git","slug":"git","permalink":"http://noritersand.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://noritersand.github.io/tags/git/"},{"name":"bare repository","slug":"bare-repository","permalink":"http://noritersand.github.io/tags/bare-repository/"}]},{"title":"Unix/Linux: 파일 내용 읽어서 환경변수로 설정하기","slug":"Unix-Linux-파일-내용-읽어서-환경변수로-설정하기","date":"2018-07-06T07:13:07.000Z","updated":"2018-07-11T00:15:13.206Z","comments":true,"path":"os/unix-linux/Unix-Linux-파일-내용-읽어서-환경변수로-설정하기/","link":"","permalink":"http://noritersand.github.io/os/unix-linux/Unix-Linux-파일-내용-읽어서-환경변수로-설정하기/","excerpt":"","text":"쉽죠잉export VARIABLE_NAME = $( cat FILE_LOCATION ) export PID=$(cat /usr/local/tomcat8.5-6/bin/catalina.pid)echo $PID","categories":[{"name":"os","slug":"os","permalink":"http://noritersand.github.io/categories/os/"},{"name":"unix/linux","slug":"os/unix-linux","permalink":"http://noritersand.github.io/categories/os/unix-linux/"}],"tags":[{"name":"unix","slug":"unix","permalink":"http://noritersand.github.io/tags/unix/"},{"name":"linux","slug":"linux","permalink":"http://noritersand.github.io/tags/linux/"},{"name":"evironment variable","slug":"evironment-variable","permalink":"http://noritersand.github.io/tags/evironment-variable/"}]},{"title":"Unix/Linux: Vim 단축키.jpg","slug":"Unix-Linux-Vim-단축키-jpg","date":"2018-07-06T06:57:35.000Z","updated":"2018-07-11T00:15:13.205Z","comments":true,"path":"os/unix-linux/Unix-Linux-Vim-단축키-jpg/","link":"","permalink":"http://noritersand.github.io/os/unix-linux/Unix-Linux-Vim-단축키-jpg/","excerpt":"","text":"위키: http://www.joinc.co.kr/modules/moniwiki/wiki.php/Site/Vim/Documents/UsedVim","categories":[{"name":"os","slug":"os","permalink":"http://noritersand.github.io/categories/os/"},{"name":"unix/linux","slug":"os/unix-linux","permalink":"http://noritersand.github.io/categories/os/unix-linux/"}],"tags":[{"name":"unix","slug":"unix","permalink":"http://noritersand.github.io/tags/unix/"},{"name":"linux","slug":"linux","permalink":"http://noritersand.github.io/tags/linux/"},{"name":"vim","slug":"vim","permalink":"http://noritersand.github.io/tags/vim/"}]},{"title":"윈도우: pscp 원격 서버에 파일 업로드","slug":"윈도우-pscp-원격-서버에-파일-업로드","date":"2018-07-06T06:53:54.000Z","updated":"2018-07-11T00:15:13.212Z","comments":true,"path":"os/windows/윈도우-pscp-원격-서버에-파일-업로드/","link":"","permalink":"http://noritersand.github.io/os/windows/윈도우-pscp-원격-서버에-파일-업로드/","excerpt":"","text":"PSCP, PuTTY Secure Copy client 윈도우에서 putty를 설치하고 명령 프롬프트나 파워쉘에서 사용할 수 있다.pscp 보낼파일경로 사용자@호스트:목적지경로 examplepscp C:/project/workspace/myfile.js someuser@12.34.56.78:/test/myfile.js # 비밀번호 별도 입력pscp -pw P@ssWord C:/project/workspace/myfile.js someuser@12.34.56.78:/test/myfile.js # 비밀번호도 같이","categories":[{"name":"os","slug":"os","permalink":"http://noritersand.github.io/categories/os/"},{"name":"windows","slug":"os/windows","permalink":"http://noritersand.github.io/categories/os/windows/"}],"tags":[{"name":"windows","slug":"windows","permalink":"http://noritersand.github.io/tags/windows/"},{"name":"pscp","slug":"pscp","permalink":"http://noritersand.github.io/tags/pscp/"}]},{"title":"윈도우: 보호된 프로세스 날리기","slug":"윈도우-보호된-프로세스-날리기","date":"2018-07-06T06:52:40.000Z","updated":"2018-07-11T00:15:13.212Z","comments":true,"path":"os/windows/윈도우-보호된-프로세스-날리기/","link":"","permalink":"http://noritersand.github.io/os/windows/윈도우-보호된-프로세스-날리기/","excerpt":"","text":"프로세스나 서비스 강제종료 시 “액세스가 거부되었습니다.” 현상이 발생한다면? http://processhacker.sourceforge.net/index.php ??? PROFIT!!","categories":[{"name":"os","slug":"os","permalink":"http://noritersand.github.io/categories/os/"},{"name":"windows","slug":"os/windows","permalink":"http://noritersand.github.io/categories/os/windows/"}],"tags":[{"name":"windows","slug":"windows","permalink":"http://noritersand.github.io/tags/windows/"},{"name":"process kill","slug":"process-kill","permalink":"http://noritersand.github.io/tags/process-kill/"}]},{"title":"Atom: 초기 설정","slug":"Atom-초기-설정","date":"2018-06-19T02:12:54.000Z","updated":"2018-07-11T00:15:13.185Z","comments":true,"path":"tools/Atom-초기-설정/","link":"","permalink":"http://noritersand.github.io/tools/Atom-초기-설정/","excerpt":"","text":"atom 1.27.2 기준. 자동완성 설정 바꾸기Settings &gt; Installed Packages &gt; autocomplete-plus의 설정에서,Keymap For Comfirming A Suggestions를 tab으로 변경한다. 붙여넣기 시 자동 들여쓰기 해제Settings &gt; Editor에서Auto Indent On Paste 체크 해제. 플러그인 설치 url-encode","categories":[{"name":"tools","slug":"tools","permalink":"http://noritersand.github.io/categories/tools/"}],"tags":[{"name":"tools","slug":"tools","permalink":"http://noritersand.github.io/tags/tools/"},{"name":"atom","slug":"atom","permalink":"http://noritersand.github.io/tags/atom/"}]},{"title":"wireshark: 와이어샤크 네트워크 프로토콜 분석툴","slug":"wireshark-와이어샤크-네트워크-프로토콜-분석툴","date":"2018-04-18T09:06:23.000Z","updated":"2018-07-11T00:15:13.210Z","comments":true,"path":"tools/wireshark-와이어샤크-네트워크-프로토콜-분석툴/","link":"","permalink":"http://noritersand.github.io/tools/wireshark-와이어샤크-네트워크-프로토콜-분석툴/","excerpt":"","text":"참고한 글 https://www.wireshark.org/download.html https://wiki.wireshark.org/DisplayFilters#Examples https://openmaniak.com/kr/wireshark_filters.php#display http://www.ktman.pe.kr/internet/58491 http://blog.daum.net/coy486/9 로컬호스트 트래픽 캡쳐하기 tcp.port eq 80and httpand (ip.src eq 127.0.0.1 or ip.dst eq 127.0.0.1)and http.request.uri eq \"/product/productDetail\" tcp 이면서 http 이고 port가 80이며 127.0.0.1 IP와 주거나 받은것 중 URI가 ‘/product/productDetail’ 것만 필터링.","categories":[{"name":"tools","slug":"tools","permalink":"http://noritersand.github.io/categories/tools/"}],"tags":[{"name":"todo","slug":"todo","permalink":"http://noritersand.github.io/tags/todo/"},{"name":"wireshark","slug":"wireshark","permalink":"http://noritersand.github.io/tags/wireshark/"}]},{"title":"sublime text: 쓸만한 패키지 모음","slug":"sublime-text-쓸만한-패키지-모음","date":"2018-04-18T08:39:17.000Z","updated":"2018-07-11T00:15:13.209Z","comments":true,"path":"tools/sublime-text-쓸만한-패키지-모음/","link":"","permalink":"http://noritersand.github.io/tools/sublime-text-쓸만한-패키지-모음/","excerpt":"","text":"Case Conversion케이스 변환 플러그인.https://packagecontrol.io/packages/Case%20Conversion StyleToken파일 내에서 특정 단어별 하이라이팅 기능.https://packagecontrol.io/packages/StyleToken File​Diffs간단한 diff 뷰어. diff 성능 자체는 그닥… (shell의 기본 diff와 거의 비슷)https://packagecontrol.io/packages/FileDiffs Sublimergediff 기능은 최강이지만 유료다. (35달러)http://www.sublimerge.com/ ConvertToUTF8서브라임 텍스트가 지원하지 않는 인코딩으로 저장된 파일을 저장하거나 수정할 수 있게 한다. (가령 EUC-KR 같은)https://packagecontrol.io/packages/ConvertToUTF8 WinMerge서브라임에서 마지막으로 활성화한 view와 현재 view를 WinMerge를 실행해 비교하는 플러그인. 물론 WinMerge가 깔려있어야 한다.https://packagecontrol.io/packages/WinMerge Bracket​Highlighter괄호의 시작과 끝을 행 번호 영역에 표시해주는 플러그인.https://packagecontrol.io/packages/BracketHighlighter Compare Side-By-SideFileDiffs보다 보기 좋은 diff 뷰어.https://packagecontrol.io/packages/Compare%20Side-By-Side Sync View Scroll여러 view의 스크롤을 동기화하는 플러그인. 심지어 좌우 스크롤도 동기화된다.https://packagecontrol.io/packages/Sync%20View%20Scroll","categories":[{"name":"tools","slug":"tools","permalink":"http://noritersand.github.io/categories/tools/"}],"tags":[{"name":"sublime text","slug":"sublime-text","permalink":"http://noritersand.github.io/tags/sublime-text/"},{"name":"plugin","slug":"plugin","permalink":"http://noritersand.github.io/tags/plugin/"}]},{"title":"eclipse: easy console grepper 권장 설정","slug":"eclipse-easy-console-grepper-권장-설정","date":"2018-04-18T08:28:49.000Z","updated":"2018-07-11T00:15:13.207Z","comments":true,"path":"tools/eclipse-easy-console-grepper-권장-설정/","link":"","permalink":"http://noritersand.github.io/tools/eclipse-easy-console-grepper-권장-설정/","excerpt":"","text":"","categories":[{"name":"tools","slug":"tools","permalink":"http://noritersand.github.io/categories/tools/"}],"tags":[{"name":"eclipse","slug":"eclipse","permalink":"http://noritersand.github.io/tags/eclipse/"},{"name":"easy console grepper","slug":"easy-console-grepper","permalink":"http://noritersand.github.io/tags/easy-console-grepper/"}]},{"title":"eclipse: svn repository 접근권한 초기화 방법","slug":"eclipse-svn-repository-접근권한-초기화-방법","date":"2018-04-18T02:30:42.000Z","updated":"2018-07-11T00:15:13.208Z","comments":true,"path":"tools/eclipse-svn-repository-접근권한-초기화-방법/","link":"","permalink":"http://noritersand.github.io/tools/eclipse-svn-repository-접근권한-초기화-방법/","excerpt":"","text":"Window &gt; Preferences &gt; General &gt; Security &gt; Secure Storage에 리셋 기능이 있음. 만약 위 방법으로 안된다면 아래 경로에 있는 설정파일을 삭제하면 된다.%APPDATA%\\Subversion\\auth 하위 폴더를 모두 삭제 … 하지 말고 모든 하위 폴더 내의 파일만 삭제한다.","categories":[{"name":"tools","slug":"tools","permalink":"http://noritersand.github.io/categories/tools/"}],"tags":[{"name":"eclipse","slug":"eclipse","permalink":"http://noritersand.github.io/tags/eclipse/"}]},{"title":"eclipse: hot code replace","slug":"eclipse-hot-code-replace","date":"2018-04-18T02:02:53.000Z","updated":"2018-07-11T00:15:13.207Z","comments":true,"path":"tools/eclipse-hot-code-replace/","link":"","permalink":"http://noritersand.github.io/tools/eclipse-hot-code-replace/","excerpt":"","text":"참고한 글 http://www.mkyong.com/eclipse/how-to-configure-hot-deploy-in-eclipse/ 이클립스에선 JVM을 디버그 모드로 구동한 후, 런타임이 종료되지 않은 상태에서(WAS를 띄워놓은 것과 같은 상태) 클래스 파일의 변경이 감지되면 JVM 재시작 없이 변경된 클래스파일을 교체하는 hot code replace 기능을 제공한다. (hot deploy 또는 hot swap 이라고도 한다.) 유료 플러그인인 JRebel과 비교하면 초라하지만… 없는 것보단 낫다. 설정여기선 톰캣 플러그인을 예로 든다. 우선 톰캣 서버 설정(서버 이름을 더블클릭 해서 진입한다. 서버 목록은 이클립스에서 Servers view를 활성화해야 볼 수 있다.)의 Overview 탭에서 ‘Automatically publish when resources change’ 항목에 체크하고 (만약 ‘Serve modules without publishing’을 활성화했다면 이 과정은 생략해도 된다): Modules 탭에서 보이는 Edit 버튼을 눌러 Auto reloading enabled의 체크를 해제한다.이후 WAS를 디버그 모드로 구동한 뒤 소스를 수정하면 된다. 주의사항hot code replace의 적용 범위는 메서드 본문에만 한정된다. 다음에 해당하는 코드를 추가하거나 변경할 땐 replace가 불가능하며 반드시 JVM을 재시작해야 한다: 클래스와 메서드의 선언부 클래스 변수 혹은 인스턴스 변수 스태틱 블록 replace가 불가능한 변경이 감지되면 아래와 같은 대화창이 나타나고 변경한 소스는 다음 재시작 때까지 반영되지 않는다. replace에 실패했으니 무시하던지, JVM을 종료하던지, 아니면 재시작을 하라는 대화창이다. 무시할 경우 마지막으로 replace에 성공한 시점을 유지하지만 경우에 따라서 ClassNotFoundException 같은 예외가 발생할 수 있다. 대화창이 나타나는게 귀찮다면 옵션에서 아예 꺼버릴 수도 있다. 이클립스 mars 기준으로 Preferences &gt; Java &gt; Debug &gt; Hot Code Replace &gt; show error when hot code replace fails. 체크박스를 해제하면 된다. 그리고 간혹 익명 클래스나 중첩 클래스의 내용을 변경할 때 hot code replace가 이상하게 작동하는 때가 있다. 이 때는 그냥 재시작 하면 된다. 하여간안되면껏다켜는게진리","categories":[{"name":"tools","slug":"tools","permalink":"http://noritersand.github.io/categories/tools/"}],"tags":[{"name":"eclipse","slug":"eclipse","permalink":"http://noritersand.github.io/tags/eclipse/"},{"name":"hot deploy","slug":"hot-deploy","permalink":"http://noritersand.github.io/tags/hot-deploy/"},{"name":"hot code replace","slug":"hot-code-replace","permalink":"http://noritersand.github.io/tags/hot-code-replace/"}]},{"title":"개발툴, 유틸리티 링크 모음","slug":"개발툴-유틸리티-링크-모음","date":"2018-04-17T09:47:33.000Z","updated":"2018-07-13T09:00:53.004Z","comments":true,"path":"tools/개발툴-유틸리티-링크-모음/","link":"","permalink":"http://noritersand.github.io/tools/개발툴-유틸리티-링크-모음/","excerpt":"","text":"DBMS tool Oracle SQL Developer: http://www.oracle.com/technetwork/developer-tools/sql-developer/overview/index.html SQL Developer는 오라클 전용 DBMS 툴로 런타임 환경이나 instant client 없이 서버에 연결할 수 있다. Toad: http://www.toadworld.com/m/freeware/default.aspx SQLGate: http://www.sqlgate.com/kr/download/ Orange: http://www.warevalley.com/xml/download/orange_trial QueryBox: http://www.querybox.com/ DMBS 가리지 않고 접속할 수 있는 국산 툴. 기업용은 유료. 트래픽 디버깅 툴 Fiddler: http://www.telerik.com/fiddler 웹 디버깅 툴. 파폭은 SSL 인증서 때문에 빡칠 수 있다. Wirehsark: https://www.wireshark.org/download.html 패킷 추적 툴. IDE Eclipse: http://www.eclipse.org/downloads/ IntelliJ: http://www.jetbrains.com/idea/download/index.html jEdit: http://www.jedit.org/index.php?page=download NetBeans: https://netbeans.org/downloads/index.html Cloud9 (WEB): https://c9.io/ WebStorm: http://www.jetbrains.com/webstorm/download/index.html Aptana: http://www.aptana.com/products/studio3/download ZED: http://zedapp.org/ 텍스트 에디터 Komodo Edit: http://www.activestate.com/komodo-edit Sublime Text: http://www.sublimetext.com EditPlus: http://editplus.com/ Coda: http://panic.com/coda/ UltraEdit: http://www.ultraedit.com/loc/ko/index_ko.html Atom: https://atom.io/ ERD eXERD: http://www.exerd.com Project manager / Issue tracker Trello: https://trello.com/ Taiga: https://taiga.io JIRA: https://ko.atlassian.com/software/jira 유료, 설치형. 마인드맵 XMind: http://www.xmind.net FreeMind: http://freemind.sourceforge.net/wiki/index.php/Main_Page Office LibreOffice: http://ko.libreoffice.org/download/ UML/MDA StarUML: http://staruml.sourceforge.net/ko/ Draw.io (web): http://www.draw.io Draw.io Pro (chrome app): https://chrome.google.com/webstore/detail/drawio-pro/onlkggianjhjenigcpigpjehhpplldkc?utm_source=plus Gliffy (web): http://www.gliffy.com 45+ 온라인 드로잉 툴: http://www.smashingapps.com/2011/08/26/45-free-online-tools-to-create-charts-diagrams-and-flowcharts 텔넷/SSH/FTP 클라이언트 PuTTY: http://www.chiark.greenend.org.uk/~sgtatham/putty/ Xshell: http://www.netsarang.co.kr/download/main.html WinSCP: https://winscp.net/eng/download.php Presentation Prezi(web): http://prezi.com Slideshare(web): http://www.slideshare.net Mobile development troy (web): http://troy.labs.daum.net/ Adobe Edge Inspect: https://creative.adobe.com/ko/products/inspect JSON viewer/editor https://www.jsoneditoronline.org https://jsonviewer.codeplex.com/ Java decompiler JD Project: http://jd.benow.ca/ ETC. VirtualDVD: http://ohsoft.net","categories":[{"name":"tools","slug":"tools","permalink":"http://noritersand.github.io/categories/tools/"}],"tags":[{"name":"link","slug":"link","permalink":"http://noritersand.github.io/tags/link/"}]},{"title":"sublime text: 초기 설정","slug":"sublime-text-초기-설정","date":"2018-04-17T04:32:10.000Z","updated":"2018-07-12T08:58:42.563Z","comments":true,"path":"tools/sublime-text-초기-설정/","link":"","permalink":"http://noritersand.github.io/tools/sublime-text-초기-설정/","excerpt":"","text":"package control 설치ctrl+shift+p 로 팔레트를 열고 install package control 한글 인코딩 지원 패키지 설치ctrl+shift+p 누른후 보이는 커맨드 창에서 install package [enter] &gt; ConvertToUTF8 작성자 저장용 사용자 설정settings - user&#123; \"auto_complete_commit_on_tab\": true, \"fallback_encoding\": \"UTF-8\", \"font_face\": \"Consolas\", \"font_size\": 11, \"show_encoding\": true, \"show_line_endings\": true&#125; key bindings - user[ &#123; \"keys\": [\"ctrl+k\", \"ctrl+k\"], \"command\": \"do_nothing\" &#125;, &#123; \"keys\": [\"ctrl+k\", \"ctrl+backspace\"], \"command\": \"do_nothing\" &#125;, &#123; \"keys\": [\"f9\"], \"command\": \"save_all\" &#125;, &#123; \"keys\": [\"f8\"], \"command\": \"sort_lines\", \"args\": &#123;\"case_sensitive\": false&#125; &#125;, &#123; \"keys\": [\"ctrl+f8\"], \"command\": \"sort_lines\", \"args\": &#123;\"case_sensitive\": true&#125; &#125;] key bindings - 예전에 쓰던거[ &#123; \"keys\": [\"ctrl+shift+c\"], \"command\": \"toggle_comment\", \"args\": &#123; \"block\": false &#125; &#125;, &#123; \"keys\": [\"ctrl+shift+/\"], \"command\": \"toggle_comment\", \"args\": &#123; \"block\": true &#125; &#125;, &#123; \"keys\": [\"ctrl+shift+d\"], \"command\": \"run_macro_file\", \"args\": &#123;\"file\": \"res://Packages/Default/Delete Line.sublime-macro\"&#125; &#125;, &#123; \"keys\": [\"ctrl+shift+k\"], \"command\": \"duplicate_line\" &#125;]","categories":[{"name":"tools","slug":"tools","permalink":"http://noritersand.github.io/categories/tools/"}],"tags":[{"name":"sublime text","slug":"sublime-text","permalink":"http://noritersand.github.io/tags/sublime-text/"},{"name":"tools","slug":"tools","permalink":"http://noritersand.github.io/tags/tools/"}]},{"title":"eclipse: 초기 설정","slug":"eclipse-초기-설정","date":"2018-04-17T02:20:58.000Z","updated":"2018-07-11T00:15:13.208Z","comments":true,"path":"tools/eclipse-초기-설정/","link":"","permalink":"http://noritersand.github.io/tools/eclipse-초기-설정/","excerpt":"","text":"참고한 글 http://www.eclipse.org/downloads http://tomcat.apache.org 자바독 자동완성Window &gt; Preferences &gt; Java &gt; Code Style &gt; Code Templates 메뉴로 이동하고 항목 중 Types의 Edit 창을 열어서 다음처럼 작성한다./** * $&#123;tags&#125; * @since $&#123;id:date('yyyy-MM-dd')&#125; * @author $&#123;user&#125; */ ${date} 태그는 기본포멧이 yyyy.mm.dd. 으로 되어 있다.$&#123;date&#125; --&gt; 2015. 7. 1. 만약 포맷을 yyyy-MM-dd로 바꾸고 싶다면 이클립스 실행파일과 같은 폴더에 있는 eclipse.ini 에 다음 줄을 추가하고 이클립스를 재시작한다.-Duser.language=fr-CA 위 방법은 Neon.1a Release (4.6.1) 에선 통하지 않고 (2016-11-19 확인) 템플릿 변수 ${date}를 다음처럼 작성해야 된다.$&#123;id:date(&apos;yyyy-MM-dd&apos;)&#125; FormatterWindow &gt; Preferences &gt; Java &gt; Code Style &gt; Formatter 메뉴로 이동, New...를 클릭해서 새 프로파일을 생성한다.이후 자동으로 프로파일 에딧창으로 이동되는데 여기서 Comments 탭으로 이동 -&gt; New line after @param tags를 체크 해제한다.이 작업을 JavaScript &gt; Code Style &gt; Formatter 에서도 반복한다. JSP 템플릿새로운 JSP 페이지를 작성 할 때 구성하는 템플릿 파일을 다음과 같이 변경 가능 하다. Window &gt; Perferences &gt; Web &gt; JSP Files &gt; Editor &gt; Template 오른쪽 화면의 New JSP File(html) 을 선택 하고 Edit 버튼. 수정 후 Ok.&lt;%@ page language=\"java\" contentType=\"text/html; charset=$&#123;encoding&#125;\" pageEncoding=\"$&#123;encoding&#125;\"%&gt;&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=$&#123;encoding&#125;\"&gt; &lt;!-- if HTML5 --&gt; &lt;!-- meta charset=$&#123;encoding&#125;\" --&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt;$&#123;cursor&#125;&lt;/body&gt;&lt;/html&gt; 작성자가 쓰는 단축키 설정 Save All: f9 (In Windows, File) Open Implementation: f4 (In Windows, Navigate) Open Implementation은 Open Declaration(F3)과 다르게 인터페이스가 아니라 구체화된 클래스로 이동시킨다. Open Type Hierarchy: unbined Find Text In File: ctrl+alt+f (In Windows, Search) File Search: ctrl+h (In Windows, Search) Open Search Dialog: unbined Watch: ctrl+alt+w (In Dialogs and Windows) 디버깅 기능으로 특정 변수, 혹은 표현식을 감시한다. Compare with HEAD Revision: ctrl+alt+pagedown (In Windows, Git) Show in History: ctrl+alt+pageup (In Windows, Git) Show Key Assist: ctrl+0 (In Dialogs and Windows, Window) Add Bookmark: ctrl+shift+z Build Automatically: ctrl+alt+insert (In Dialogs and Windows, Project) Show History 같은 써드 파티 플러그인의 기능은 단축키가 작동하지 않을때가 있는데 이 때는 Customize Perspective &gt; Action Set Availability에서 해당 플러그인의 영역을 추가해야 한다. (show history는 SVN을 체크) DEBUG 모드로 구동할 때 uncaught exception에서 브레이크 걸지 않기 Window &gt; Preferences &gt; Suspend execution on uncaught exceptions 체크 해제 인코딩 환경 설정 eclipse.ini에 -Dfile.encoding=UTF-8 추가 General &gt; Workspace 의 Text file encoding을 Other-UTF-8로 변경 Window &gt; Preferences &gt; Web &gt; CSS Files &gt; UTF-8 Window &gt; Preferences &gt; Web &gt; Jsp Files &gt; UTF-8 Window &gt; Preferences &gt; Web &gt; HTML Files 우측 화면의 Encoding을 ISO 10646/Unicode(UTF-8) 로 변경 후 Ok 버튼 클릭 자바 스크립트 파일 한글 인코딩을 UTF-8로 변경 Window &gt; Preferences &gt; General &gt; Contents type 우측 화면의 Text-Javascript의 Default encoding을 utf-8로 변경 후 update 버튼 클릭","categories":[{"name":"tools","slug":"tools","permalink":"http://noritersand.github.io/categories/tools/"}],"tags":[{"name":"eclipse","slug":"eclipse","permalink":"http://noritersand.github.io/tags/eclipse/"}]},{"title":"JavaScript: WindowEventHandlers.onunload","slug":"JavaScript-WindowEventHandlers-onunload","date":"2018-03-27T03:50:10.000Z","updated":"2018-07-11T00:15:13.191Z","comments":true,"path":"javascript/JavaScript-WindowEventHandlers-onunload/","link":"","permalink":"http://noritersand.github.io/javascript/JavaScript-WindowEventHandlers-onunload/","excerpt":"","text":"참고한 글 https://developer.mozilla.org/ko/docs/Web/API/WindowEventHandlers/onunload window.onunload = funcRef; 얼럿은 차단되지만 스크립트는 실행됨을 확인했다. 페이지를 이동하거나 새로고침하거나 브라우저를 끌 때도 작동한다.비슷한 이름의 onbeforeunload와 onclose가 있지만 지원하지 않는 브라우저가 많다.","categories":[{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/categories/javascript/"}],"tags":[{"name":"todo","slug":"todo","permalink":"http://noritersand.github.io/tags/todo/"},{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/tags/javascript/"},{"name":"windows","slug":"windows","permalink":"http://noritersand.github.io/tags/windows/"},{"name":"browser","slug":"browser","permalink":"http://noritersand.github.io/tags/browser/"},{"name":"eventhandlers","slug":"eventhandlers","permalink":"http://noritersand.github.io/tags/eventhandlers/"},{"name":"onclose","slug":"onclose","permalink":"http://noritersand.github.io/tags/onclose/"},{"name":"onunload","slug":"onunload","permalink":"http://noritersand.github.io/tags/onunload/"},{"name":"web","slug":"web","permalink":"http://noritersand.github.io/tags/web/"}]},{"title":"Git: 명령어 정리","slug":"Git-명령어-정리","date":"2018-03-21T01:16:45.000Z","updated":"2018-07-16T00:59:06.432Z","comments":true,"path":"git/Git-명령어-정리/","link":"","permalink":"http://noritersand.github.io/git/Git-명령어-정리/","excerpt":"","text":"참고한 글 https://git-scm.com/book/ko/v2 http://learnbranch.urigit.com/ addstaging / do track작업폴더의 파일을 깃이 추적하게 하거나 커밋을 위한 준비상태로 만듦.git add *git add .git add *.javagit add README.TXT 모든 추적 및 추적되지 않는 파일의 변경 내용을 추가git add -Agit add --all# git rm을 쓰지 않고 직접 삭제한 파일도 모두 스테이징할 때 쓰면 유용하다. 대화형으로 파일 스테이징git add -i blame바보같은 커밋을 비난하기 위한 명령어 데이터의 각 줄을 누가 언제 마지막으로 고쳤는지 확인할 수 있으며 디버깅 용도로 사용한다. Git으로 버그 찾기 파일 커밋 정보 줄 단위로 보기git blame 파일 특정 라인만 보기git blame -L 시작라인,종료라인 파일 git blame -L 12,22 simplegit.rb 파일의 줄 단위의 복사, 붙여넣기, 이동 정보 보기git blame -M 파일 파일의 줄 단위의 이동과 원본 파일 정보 보기git blame -C -C 파일 branch브랜치 생성현재 브랜치 기반의 신규 브랜치를 생성한다.git branch mybranch 다른 커밋 기반의 브랜치 생성‘체크아웃으로 헤드 이동 후 브랜치 생성’의 단축형. 여기서 커밋은 체크섬 외에 다른 브랜치나 태그가 올 수도 있다.git branch 브랜치명 커밋 브랜치 확인git branch # 로컬 저장소의 브랜치만 출력git branch -r # 리모트 브랜치 목록 보기git branch -a # 로컬과 리모트 브랜치 모두 보기git branch -v # 마지막 커밋 메시지도 함께 출력한다git branch -vv # 추적중인 브랜치 확인 머지 여부 확인머지가 완료되었거나 그렇지 않은 브랜치만 표시한다. 삭제해도 되는 브랜치를 조회할 때 사용한다.git branch --mergedgit branch --no-merged 현재 브랜치를 다른 브랜치에 덮어쓰기새 브랜치를 생성할 때 -f 옵션을 사용하면 이미 존재하는 브랜치를 무시하고 덮어쓴다.git branch -f 대상브랜치 [커밋] 브랜치 이름변경git branch -m NAME_FROM NAME_TO 브랜치 삭제git branch -d mybranchgit branch -D mybranch # 브랜치 강제삭제(보통 non-merged 브랜치를 삭제할 때 사용) checkout브랜치 이동다른 브랜치의 마지막 커밋(가장 최근 커밋)으로 헤드만 이동한다. 이 말은 깃 디렉토리만 다른 커밋의 스냅샷으로 변경된다는 뜻이다. 워킹 트리(working tree, 실제 작업공간)와 스테이징 에어리어(staging area, 인덱스)는 그대로 유지된다.git checkout master# 만약 master라는 브랜치가 로컬에 존재하지 않으면 리모트 저장소의 데이터를 체크아웃한다. 다른 커밋으로 헤드 이동특정 커밋의 체크섬이나 태그를 입력해 해당 시점의 스냅샷으로 이동하는 것을 의미한다. 브랜치를 만들지 않고 헤드를 이동할 수 있다. 체크아웃으로 과거의 이력에 해당하는 커밋으로 이동했을 때, 깃은 이를 ‘분리된 헤드(detached HEAD)’ 상태에 있다고 하며 이 상태에서 바로 작업하는 것보다 브랜치를 생성하여 작업할 것을 권장하고 있다.git checkout 체크섬git checkout 태그 git checkout 6f9021d4a03586a787ebcef2f94dd2eca1aec941git checkout v0.3.1.5 브랜치를 새로 만들면서 체크아웃git checkout -b 브랜치 파일 변경 사항 되돌리기워킹 트리와 스테이징 에어리어를 깃 디렉토리의 내용대로 되돌린다. 이미 추적중인 대상만 되돌릴 수 있다. status에 표시되는 기준으로 modified, renamed, deleted는 되돌리지만 new file은 되돌리지 않는다.git checkout -- . # 현재 경로의 모든 파일 되돌리기git checkout HEAD . # 현재 경로의 모든 파일 되돌리기 fetch 시점으로 헤드 이동fetch로 리모트 저장소의 데이터를 받아왔을때 ‘FETCH_HEAD’라는 포인터가 생성된다. 해당 포인터의 스냅샷을 확인 후 원하는 브랜치로 이동해 머지한다.git checkout FETCH_HEADgit checkout 리모트저장소/리모트브랜치 fetch로 받아온 데이터를 머지하지 않고 새 브랜치로 생성git checkout -b FETCH_HEADgit checkout -b 생성할브랜치 리모트저장소/리모트브랜치 git checkout -b hotFix anotherServer/master # 이 명령은 지정한 원격 저장소의 브랜치를 업스트림 브랜치로 만든다. 업스트림(upstream) 브랜치 설정 #1깃이 리모트 저장소의 특정 브랜치를 추적하도록 설정하는 방법이다. 추적 중인 브랜치를 업스트림 브랜치라고 하는데, 업스트림 브랜치가 설정되어 있으면 pull이나 push 사용 시 리모트의 저장소명과 브랜치명을 생략할 수 있다.git checkout -b 로컬브랜치 리모트저장소/리모트브랜치git checkout --track 리모트저장소/리모트브랜치 # 1.6.2 이상 git checkout --track origin/serverfixBranch serverfix set up to track remote branch refs/remotes/origin/serverfix.Switched to a new branch 'serverfix' 태그로 체크아웃태그(정확히는 태그가 가리키는 커밋) 기반의 브랜치를 생성하고 동시에 체크아웃까지 하는 방법이다.git checkout -b version2 v2.0.0 # v2.0.0 기반 브랜치 version2로 체크아웃 cherry-pickcherry-pick은 커밋 하나만 리베이스하는 것이다. 다음 페이지에서 자세한 사항을 확인할 수 있다. Git 프로젝트 운영하기 선택 머지git cherry-pick 커밋명 커밋하지 않고 선택 머지git cherry-pick -n 커밋명 clean추적중이지 않은(untracked) 파일 삭제하기.git clean -fgit clean -f -d -x # ignore 설정된 파일을 포함하며 추적중이지 않은 파일과 폴더를 모두 삭제한다. clean.requireForce 설정이 true가 아니면 clean 명령은 항상 -f, -i, -n 옵션 중 하나가 명시되어야 실행된다. 기본적으로 현재 폴더를 기준으로 하위를 재귀탐색하기 때문에 recursive 옵션은 따로 없다. options: -f | --force: 삭제 기본 옵션. 설정에 따라 생략할 수도 있다. -i | --interactive: 대화 모드로 삭제 -n | --dry-run: 지워질 파일 목록 미리보기 -d: 폴더도 삭제한다. -x: ignore 룰이 적용된 파일도 삭제한다. -X: ignore 룰이 적용된 파일만 삭제한다. clone저장소 복제현재 경로에 로컬 깃 저장소가 될 디렉토리를 만들고 리모트 저장소의 데이터를 모두 받아온다. 디렉토리명을 따로 명시하지 않으면 리모트 저장소의 이름과 동일하게 생성된다.git clone ~/Documents/workspace/ex/cal/srcgit clone file://c:/users/noritersand/noriterGit/localServer localGitRepogit clone https://noritersand@dev.naver.com/git/lernforscm.git naverGitRepogit clone git://github.com/schacon/grit.git gitHubRepo 리모트 저장소를 복제하면서 bare repository로 설정git clone --bare 저장소주소 [디렉토리] 복제 시 데이터 제한하기git clone --depth 200 ~/Documents/work/ # 마지막 200개의 커밋만 복제한다. commitstaged 상태인 파일을 깃 디렉토리에 저장한다. 커밋 메시지를 입력받기 위해, 지정되어있는 에디터가 자동으로 실행되며 메시지를 작성하고 에디터를 종료하면 커밋이 완료된다. 이 때 커밋 메시지가 주석(#으로 시작하는 라인)으로만 작성되어 있으면 커밋은 취소된다.git commit 에디터 없이 커밋에디터 실행을 생략하고 메시지를 즉시 입력한다.git commit -m \"hello this is test commit\" Signed-off-by 추가커밋 메시지에 Signed-off-by를 추가한다. -s 혹은 --signoff 옵션을 사용하면 커밋 메시지에 user.name과 user.email이 자동으로 추가된다.git commit -s -m 'commit message test'[master 1204311] commit message test 1 file changed, 1 insertion(+)git log -1 HEADcommit 1204311e62660b46c375c6e4d9a61a48a9adeb1dAuthor: noritersand &lt;who@where.com&gt;Date: Thu Nov 17 10:07:35 2016 +0900 commit message test Signed-off-by: noritersand &lt;who@where.com&gt; 자동 스테이징(staging)-a 옵션을 사용하면 add 없이 커밋할 수 있다. 단, 추적 중인 파일만 자동으로 스테이징된다.git commit -a -m \"auto staging\" 마지막 커밋 수정가장 최근의 커밋을 수정할 때 사용한다. staged 상태인 파일이 있으면 마지막 커밋의 파일 변경 이력에 추가하며, 그렇지 않으면 커밋 메시지만 수정한다.git commit --amend git commit -m 'initial commit'git add forgotten_filegit commit --amend # forgotten_file이 마지막 커밋에 추가된다. 마지막 커밋을 수정하되 커밋 메시지는 재사용git commit -C HEAD --amend config깃 저장소의 설정을 조회/관리하는 명령어. --global 옵션이 없으면 저장소별 설정을 의미한다. 작업자의 이름/이메일 설정git config --global user.name \"이름\"git config --global user.email \"이메일\" 기본 편집기 설정git config --global core.editor 편집기 Diff 도구 설정git config --global merge.tool vimdiff 설정 확인git config --listgit config -lgit config --global --listgit config core.editor 단축어(alias) 만들기git config --global alias.사용할키워드 &apos;명령어&apos; git config --global alias.unstage 'reset HEAD --'git config --global alias.visual '!gitk'git config --global alias.ss 'status' 단축어 목록 보기git config --get-regexp aliasgit config --list | grep alias 단축어 삭제git config --global --unset alias.ss SSL 검증 비활성화git config --global http.sslVerify false diffunstaged와 staged의 비교git diffgit diff --check # 충돌 문자가 있거나 공백 에러가 있는지 확인 staged와 commited의 비교git diff --cachedgit diff --staged fetch리모트 저장소의 데이터를 로컬 저장소로 다운로드한다. 서버의 데이터를 모두 가져오지만 머지는 생략한다.git fetch # origin 저장소에서 데이터 다운로드git fetch pb # pb 저장소에서 데이터 다운로드git fetch --all # 모든 리모트 저장소에서 fetch 태그 받아오기리모트 저장소의 태그를 모두 받아온다. 태그’만’ 받는다.git fetch --tags help도움말 보기git help configgit config --help init디렉토리를 git 저장소로 만들기git init bare repository워킹 트리가 없는 저장소를 만든다. 이 명령은 로컬 저장소가 아닌 리모트 저장소를 생성할 때 사용한다.git init --bare log커밋 히스토리 조회git log options: -p: 각 커밋에 적용된 패치(patch, 반영된 변경사항)를 보여준다. --stat: 각 커밋에서 수정된 파일의 통계정보를 보여준다. --shortstat: –stat 옵션의 결과 중에서 수정한 파일, 추가된 줄, 삭제된 줄만 보여준다. --name-only: 커밋 정보중에서 수정된 파일의 목록만 보여준다. --name-status: 수정된 파일의 목록을 보여줄 뿐만 아니라 파일을 추가한 것인지, 수정한 것인지, 삭제한 것인지도 보여준다. --abbrev-commit: 40자 짜리 SHA-1 체크섬을 전부 보여주는 것이 아니라 처음 몇 자만 보여준다. --relative-date: 정확한 시간을 보여주는 것이 아니라 ‘2주 전’처럼 상대적인 형식으로 보여준다. --graph: 브랜치와 머지 히스토리 정보까지 아스키 그래프로 보여준다. --pretty: 지정한 형식으로 보여준다. 이 옵션에는 oneline, short, full, fuller, format이 있다. format은 원하는 형식으로 출력하고자 할 때 사용한다. --walk-reflogs: 헤드가 이동한 순서대로 로그 출력 git log -p -2 # 2개의 항목과 패치내용만 보인다.git log --pretty=oneline # 각 커밋들의 메시지와 체크섬만 한 줄씩 출력된다.git log -1 HEAD~3 # 헤드 기준 세번째 전의 커밋 로그 보기git log v1.0 v2.4 # v1.0 태그에서 v2.4 태그 사이의 로그 보기git log --oneline --decorate --graph --all # 현재 브랜치의 모든 커밋 로그를 그래프로 보기 pretty=format의 placeholder: %H: Commit hash %h: Abbreviated commit hash %T: Tree hash %t: Abbreviated tree hash %P: Parent hashes %p: Abbreviated parent hashes %an: Author name %ae: Author e-mail %ad: Author date (format respects the –date= option) %ar: Author date, relative %cn: Committer name %ce: Committer email %cd: Committer date %cr: Committer date, relative %s: Subject git log --pretty=format:\"%h %s\" --graph 더 많은 내용은 공식 도움말 참고 조회 범위 제한 옵션: -(n): 최근 n 개의 커밋만 조회한다. --since | --after: 명시한 날짜 이후의 커밋만 검색한다. --until | --before: 명시한 날짜 이전의 커밋만 조회한다. --author: 입력한 저자의 커밋만 보여준다. --committer: 입력한 커미터의 커밋만 보여준다. git log --since=2.weeksgit log --pretty=\"%h - %s\" --author=gitster --since=\"2008-10-01\" \\ --before=\"2008-11-01\" --no-merges -- t/ ls-files인덱스나 워킹 트리에 있는 파일들의 정보를 표시한다. 기본적으로 명령을 실행한 경로를 기준으로 재귀탐색한다. options: -c | --cached: -d | --deleted: -m | --modified: -o | --others: -i | --ignored: -s | --stage: -v: 파일의 상태를 표시하되 실제로는 변경되었으나 그렇지 않은것으로 간주된(assume unchanged) 파일은 소문자로 표시한다. git ls-files -v | grep ^h # assume unchanged 파일만 표시 merge현재 브랜치에 다른 브랜치를 머지한다. 만약 충돌(conflict)이 발생하면 깃은 자동으로 머지를 중단하고 충돌이 발생한 파일에 각 커밋의 내용을 표시해준다. 깃의 머지는 두 개의 부모 커밋을 가리키는 특별한 커밋을 만들어 낸다. 두 개의 부모가 있는 커밋은 ‘한 부모의 모든 작업내역과 나머지 부모의 모든 작업, 그리고 그 두 부모의 모든 부모들의 작업내역을 포함한다’라는 의미가 있다.1git merge 브랜치1 [브랜치2 브랜치3 브랜치3 ...] git merge iss123 # 헤드 브랜치(현재 브랜치)에 iss123 브랜치를 머지git merge iss123 hotfix # 헤드 브랜치에 iss123과 hotfix를 머지 나열되는 브랜치들은 현재 헤드가 가리키는 브랜치에 어떤 브랜치들을 머지할 것인지를 의미한다. 그래서 다음의 경우:git merge A B 아래와 같다:merge A and B to CURRENT_BRANCH 커밋하지 않고 머지git merge --no-commit 머지 도구 실행3-way merge에 실패했을때 사용한다. mergetool로 지정된 앱을 실행하면서 .orig 확장자로 백업파일이 생성된다.git mergetool fetch 후 머지fetch로 받아온 데이터를 현재 브랜치와 머지한다.git merge FETCH_HEAD 여러 커밋을 하나로 묶어서 머지git merge --squash TARGET_BRANCH 머지할 브랜치의 커밋 이력을 하나로 압축한 별도의 커밋을 만들고 헤드 브랜치에 머지한다. 일반 머지와 다르게 하나의 부모커밋(헤드 브랜치 기준)만 갖는다. mv파일명 수정git mv FILE_FROM FILE_TO pullfetch 후 자동 머지.git pull [리모트저장소] [브랜치] 리모트 저장소에서 데이터를 받아온다는 것은 fetch와 같지만 pull은 머지까지 한다는 점이 다르다.git pull # origin 리모트 저장소에서 현재 브랜치로 pullgit pull origin master 브랜치를 명시하지 않으면 (가능한 경우) 현재 브랜치만 자동 머지한다. 리모트의 저장소명과 브랜치명 생략은 업스트림 브랜치가 설정되어 있을 경우에만 가능하다. push로컬 저장소의 데이터를 리모트 저장소에 업로드한다.git push [리모트저장소] [브랜치] git push # origin 리모트 저장소에 현재 브랜치를 업로드git push origin other # origin에 other 브랜치 업로드. 리모트에 other 브랜치가 없으면 새로 생성한다. 업스트림 브랜치 설정 #2로컬 저장소를 init으로 생성했거나, 로컬에서 새로 생성한 브랜치일 때 업스트림 브랜치를 설정하는 방법이다.git push --set-upstream origin masterBranch master set up to track remote branch master from origin.Everything up-to-date 로컬 브랜치와 리모트 저장소의 브랜치 이름이 다를때 (혹은 리모트 저장소에 다른 브랜치를 생성할 때)git push 리모트저장소 로컬브랜치:서버브랜치 git push origin serverfix:awesome # 현재 로컬 브랜치가 serverfix 일때 리모트 브랜치 awesome을 생성하고 푸시 신규 로컬 저장소를 생성하고 리모트에 업로드touch README.mdgit initgit add README.mdgit commit -m \"first commit\"git remote add origin https://noritersand@127.0.0.1:8443/r/test.gitgit push --set-upstream origin master 로컬 저장소의 데이터 업로드git remote add origin https://noritersand@127.0.0.1:8443/r/test.gitgit push --set-upstream origin master 리모트 저장소의 태그나 브랜치 삭제git push origin --delete other # origin 저장소의 other 브랜치 삭제git push origin :v0.9 # origin 저장소의 v0.9 태그 삭제(--delete는 콜론으로 대체할 수 있음) 생성한 태그 공유push는 태그를 포함하지 않는다. 따라서 명시적인 명령으로 따로 올려야 한다.git push origin v1.5 # origin 저장소에 v1.5 태그 업로드git push --tags # 생성한 태그를 모두 업로드 rebase현재 브랜치를 다른 브랜치에 머지. merge 명령이 두 브랜치의 최종결과만을 기준으로 머지한다면 리베이스는 브랜치의 변경사항을 순서대로 다른 브랜치에 적용하며 머지한다. 저장소의 커밋 로그와 이력을 한 줄로 정리해주기 때문에 보통 완료된 브랜치를 마스터에 머지할 때 사용한다.git rebase master # 현재 브랜치를 master 브랜치로 리베이스 위의 경우 현재 브랜치(HEAD)의 델타(변경 사항)를 패치(patch)로 만들어놓고, 현재 브랜치를 master의 마지막 커밋으로 이동한 뒤, 만들어뒀던 패치를 반영하는것과 결과가 같다. 자세한 내용은 아래 링크를 참고: Git브랜치 Rebase하기 Rebase의 위험성 대화형 리베이스 도구로 여러 커밋 수정git rebase -i HEAD~3 # 헤드부터 HEAD~3까지의 커밋을 대화형으로 수정 커밋 메시지를 여러 개 수정하기 refloglog와 비슷하지만 log가 커밋 이력을 출력한다면 reflog는 헤드 이동 이력을 출력한다.$ git reflog -5 # 마지막 다섯 번의 헤드 이동 이력을 역순으로 출력2fbc899 HEAD@&#123;0&#125;: checkout: moving from master to master2fbc899 HEAD@&#123;1&#125;: pull: Merge made by the 'recursive' strategy.7107b9e HEAD@&#123;2&#125;: checkout: moving from d to master53576ad HEAD@&#123;3&#125;: merge c: Fast-forward2bc9237 HEAD@&#123;4&#125;: checkout: moving from c to d remote리모트 저장소 목록로컬 저장소에 등록된 리모트 저장소를 모두 출력하되 단축이름만 표시한다.git remote 리모트 저장소 URL 확인리모트 저장소의 단축이름과 URL을 표시한다.git remote -v 리모트 저장소 URL 바꾸기git remote set-url origin https://github.com/USERNAME/REPOSITORY.git 리모트 저장소 추가git remote add 단축이름 주소 git remote add remoteRepo https://noritersand@dev.naver.com/git/exlernforscm.git 리모트 저장소 살펴보기특정 로컬 저장소의 구체적인 정보(URL, 추적중인 브랜치 등)를 표시한다.git remote show origin # origin 저장소의 상세정보 표시 리모트 저장소 이름 바꾸기git remote rename NAME_FROM NAME_TO 리모트 저장소 삭제git remote rm 리모트저장소이름 리모트 저장소에서 쓸모가 없어진 브랜치 제거하기git remote prune 리모트저장소 reset현재 브랜치 내에서 헤드를 이동한다. staged 되돌리기(스테이징 취소)add로 인덱스에 등록한 파일을 unstaged 상태로 바꾼다. 파일을 따로 명시하지 않으면 모든 스테이징을 취소한다.git reset HEAD [파일] 커밋 되돌리기 #1체크섬이나 HEAD~숫자를 사용해서 헤드가 지난 커밋을 가리키게 할 수 있다. options: --soft: 헤드만 옮긴다. 스테이징 에어리어와 워킹 트리는 유지 --mixed: 명시하지 않을때의 기본값. 스테이징 에어리어를 헤드와 동일하게 변경한다. 워킹 트리는 유지 --hard: 헤드와 스테이징 에어리어, 워킹 트리를 모두 동일하게 변경한다. git reset --soft HEAD~2 # 헤드만 2회 이전 커밋으로 이동git reset --hard 4990ef # 헤드를 4990ef 체크섬으로 이동하고 스테이징 에어리어, 워킹 트리를 동일하게 변경 revert커밋 되돌리기 #21회 전의 커밋으로 되돌리되 단순히 헤드를 이동하고 끝나는게 아니라, 되돌려지는 내용을 기록한 새로운 커밋을 생성한다.git revert HEAD # 직전 커밋의 revert 커밋 생성 위의 경우 헤드 기준으로 가장 마지막 커밋의 변경사항을 되돌리는 커밋을 생성한다.가령 직전의 커밋이 ‘fix-a-lot.md’라는 파일을 생성한 커밋이라면 git revert HEAD는 ‘fix-a-lot.md’를 삭제하는 커밋을 만드는 것이다.git revert HEAD~1 # 1회 전 커밋의 리버트 커밋 생성git revert HEAD~3 # 3회 전 커밋의 리버트 커밋 생성git revert 3bd5055389bd059f0f781bfcfe3190bb7dfa9e5e # 3bd505 커밋의 리버트 커밋 생성git revert HEAD~4..HEAD # 직전 커밋부터 3회전 커밋까지의 변경사항을 되돌린 커밋 생성 options: -n | --no-commit: 워킹 트리와 인덱스의 상태만 되돌리고 커밋은 생성하지 않는다. -m | --mainline: 머지 커밋을 리버트 할 때 사용하는 옵션. 머지 커밋을 되돌리기commit fc30cfe9255837f6810eb75adacaf93696828afe (HEAD -&gt; revert-test)Merge: 7be20ca ca433d3# 7be20ca에 ca433d3을 머지하여 만들어진 커밋 fc30cf를 조회한 로그 머지 커밋을 되돌릴 때는 깃이 어느 부모가 메인라인이 되야하는지 알 수 있도록 -m 옵션과 함께 부모 번호(1부터 시작하는 부모 커밋을 가리키는 숫자)를 입력해줘야 한다:git revert fc30cf -m 1 여기서 1이란 git log에서 보이는 부모 커밋 중 가장 왼쪽을 의미한다. 이 경우 7be20ca가 메인라인이 되며 ca433d3의 변경사항이 되돌려진다. rm파일/폴더 삭제git rm readme.txt rm 명령어는 깃이 추적중인 파일 혹은 폴더에만 사용할 수 있다. 깃의 추적을 중단시키기실제 파일은 남기고 깃의 관리대상에서만 제외한다.git rm --cached readme.txt file-glob 패턴으로 범위삭제git rm log/\\*.log # log/디렉토리의 확장명이 log인 파일 모두 삭제git rm \\*.~ # ~로 끝나는 파일 모두 삭제 show커밋 정보 조회git show HEAD # 헤드 브랜치의 커밋 정보 조회git show v1.1 # v1.1 태그의 커밋 정보 조회git show 1c002dd4b536e7479fe34593e72e6c6c1819e53b # 체크섬으로 조회git show 1c002dd4b # 체크섬은 중복이 없는한 앞의 일부분만 명시해도 인식한다. stash커밋이나 스테이지가 아닌 별도의 공간에 변경사항을 임시 저장하거나 저장한 내용을 다시 불러오는 명령어. 스태시 생성(임시 저장본 만들기)추적 중인 파일의 모든 변경사항을 스태시에 저장되며 워킹 트리와 스테이징 에어리어는 헤드와 같아진다.git stash # 스태시 생성. stash save와 같음git stash savegit stash -k # --keep-index: staged 상태의 파일은 무시한다.git stash -u # --include-untracked: 추적중이지 않은 파일도 스태시로 저장 스태시 확인git stash list # 스태시 목록 확인git stash show # 첫 번째 스태시 상세 확인git stash show stash@&#123;0&#125; 스태시 적용(임시 저장본 불러오기)현재 브랜치에 스태시에 저장된 내용을 적용한다.git stash apply # 가장 최근의 스태시를 현재 브랜치에 적용git stash pop # 스태시를 적용하고 스택에서 삭제 apply는 스태시를 적용하되 저장한 스태시는 그대로 유지한다. 반면 pop은 적용한 스태시를 스택에서 삭제한다. 스태시는 기본적으로 modified 상태로 적용된다. --index 옵션을 사용하면 스태시를 저장할 때 staged 상태였던 파일을 다시 staged 상태로 만들어준다.git stash pop --index 스태시 삭제git stash drop # 첫 번째 스태시 삭제git stash drop stash@&#123;3&#125; # 네 번째 스태시 삭제git stash clear # 모든 스태시 삭제 스태시를 적용한 새 브랜치 만들기git stash branch BRANCH_NAME # 가장 최근의 스태시를 적용한 새 브랜치 생성git stash branch issue541 stash@&#123;1&#125; # 두 번째 스태시를 적용한 issue541 브랜치 생성 status저장소 상태 확인git status svnSVN 저장소 복제git svn clone SVN저장소주소 표준 레이아웃 SVN 저장소 복제표준 레이아웃(trunk와 branches, tags 폴더가 같은 위치에 있는 구조)을 사용하는 SVN 저장소를 복제할 때 사용한다.git svn clone -s SVN저장소주소 비표준 레이아웃 SVN 저장소 복제trunk와 branches, tags 폴더의 위치를 각각 지정하는 방식이다.git svn clone -T 트렁크경로\\-b 브랜치경로\\-t 태그경로\\svn저장소 표준 레이아웃 SVN 저장소의 특정 리비전 복제git svn clone -s -r 2321 표준 레이아웃을 사용하는 SVN 저장소를 복제하고 모든 리모트 브랜치에 접두어 추가하기git svn clone -s --prefix svn/ svn저장소 상위의 SVN 저장소에서 갱신하고 재정렬하기git svn rebase 상위의 SVN 저장소에 커밋데이터 올리기git svn dcommit 상위 SVN 저장소에 푸싱될 커밋 목록 보기git svn dcommit -n SVN 저장소 로그 보기git svn log SVN 저장소 파일의 커밋정보 줄단위로 보기git svn blame 파일 tag태그 조회git tag lightweight 태그 만들기특정 커밋지점의 포인터를 생성(책갈피와 비슷한 개념)git tag v2.2 # 현재 브랜치의 마지막 커밋에 v2.2 태그 생성 annotated 태그 만들기이름, 이메일, 날짜, 메시지를 저장하는 태그를 생성함git tag -a v1.1 -m \"my version 1.1\" 지나간 커밋에 태그 만들기체크섬을 알고 있다면 예전 커밋에도 태그할 수 있다.git tag v0.8 9fceb02 태그에 서명GPG(GNU Privacy Guard) 개인키로 태그에 서명git tag -s 태그명 [-m &quot;태그메시지&quot;] git tag -s v1.5 -m \"my signed 1.5 tag\" 태그 서명 검증태그서명에 사용된 키가 공개키인지 검증한다.git tag -v v1.0 태그 삭제git tag -d v0.9 update-index파일을 인덱스에 등록하거나 수정한다. options: --add: --remove: --refresh: 워킹트리에 대한 인덱스를 갱신한다. --really-refresh: --refresh와 비슷하지만, 이 옵션은 ‘변경되지 않음’ 상태인 파일도 갱신한다. --assume-unchanged: 특정 파일을 변경되지 않은 것으로 간주한다. 이후 해당 파일은 스테이지 목록에 나타나지 않는다. --no-assume-unchanged: ‘변경되지 않음’ 상태의 파일을 되돌린다. 변경된 파일을 스테이지 대상 목록(Unstaged Changes)에서 제외하기git update-index --assume-unchanged IGNORE_ME # IGNORE_ME 파일을 변경되지 않은 것으로 간주함. ‘변경되지 않음’ 되돌리기 #1git update-index --no-assume-unchanged IGNORE_ME ‘변경되지 않음’ 되돌리기 #2git update-index --really-refresh","categories":[{"name":"git","slug":"git","permalink":"http://noritersand.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://noritersand.github.io/tags/git/"}]},{"title":"JavaScript: 생성자 함수 constructor function","slug":"JavaScript-생성자-함수-constructor-function","date":"2018-03-20T08:19:12.000Z","updated":"2018-07-11T00:15:13.198Z","comments":true,"path":"javascript/JavaScript-생성자-함수-constructor-function/","link":"","permalink":"http://noritersand.github.io/javascript/JavaScript-생성자-함수-constructor-function/","excerpt":"","text":"참고한 글 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/constructor https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new http://tobyho.com/2010/11/22/javascript-constructors-and/ 생성자 함수가 일반 함수로 호출되는것을 방지하는 방법function Person(name)&#123; if (!(this instanceof Person)) &#123; return new Person(name); &#125; this.name = name;&#125;var bob = new Person('bob');var bob2 = Person('bob');bob instanceof Person; // truebob2 instanceof Person; // true new Object()와 Object()의 결과가 같은 이유는 Object 함수가 위처럼 되어 있기 때문이다. 생성자 함수가 new 키워드 없이 일반 함수로써 호출되면 this는 생성자 함수의 프로토타입이 아니라 함수를 소유하고있는 객체가 된다. (실행기가 브라우저라면 this는 Window다.) 생성자의 메서드function Person(name)&#123; this.name = name; this.sayHi = function() &#123; return 'Hi, I am ' + this.name; &#125;&#125; 위의 코드는 다음처럼 작성하는게 좋다:function Person(name) &#123; this.name = name;&#125;Person.prototype.sayHi = function() &#123; return 'Hi, I am ' + this.name;&#125;; 왜냐하면 첫 번째 코드는 생성되는 인스턴스 개수만큼 sayHi() 메서드가 생성되지만 두 번째 코드는 프로토타입의 메서드로 딱 한 번만 생성되고 Person의 인스턴스들은 이 프로토타입의 메서드를 공유하기 때문이다. 즉, 불필요한 함수 생성으로 메모리가 낭비되는걸 방지 할 수 있다. 생성자 메서드생성자 메서드(constructor method)는 ES2015(ES6)에 추가된 class 구문 내에서 사용한다. 생성자 함수가 아니다.class Square extends Polygon &#123; constructor(length) &#123; // Here, it calls the parent class' constructor with lengths // provided for the Polygon's width and height super(length, length); // Note: In derived classes, super() must be called before you // can use 'this'. Leaving this out will cause a reference error. this.name = 'Square'; &#125; get area() &#123; return this.height * this.width; &#125; set area(value) &#123; this.area = value; &#125;&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/categories/javascript/"}],"tags":[{"name":"todo","slug":"todo","permalink":"http://noritersand.github.io/tags/todo/"},{"name":"ecmascript","slug":"ecmascript","permalink":"http://noritersand.github.io/tags/ecmascript/"},{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/tags/javascript/"},{"name":"constructor","slug":"constructor","permalink":"http://noritersand.github.io/tags/constructor/"},{"name":"function","slug":"function","permalink":"http://noritersand.github.io/tags/function/"}]},{"title":"JavaScript: Window.postMessage 교차 출처간 메시지 통신","slug":"JavaScript-Window-postMessage-교차-출처간-메시지-통신","date":"2018-03-20T08:15:34.000Z","updated":"2018-07-11T00:15:13.190Z","comments":true,"path":"javascript/JavaScript-Window-postMessage-교차-출처간-메시지-통신/","link":"","permalink":"http://noritersand.github.io/javascript/JavaScript-Window-postMessage-교차-출처간-메시지-통신/","excerpt":"","text":"참고한 글 https://developer.mozilla.org/en-US/docs/Web/API/Window/postMessage 브라우저 호환IE는 11부터 완전히 지원하고 IE8, IE9는 프레임에서만, IE10은 제한적으로만 지원한다. 그 외 브라우저는 모두 가능한걸로… 악의축 자바스크립트에서는 어떤 윈도우와 또 다른 윈도우의 스킴과 호스트명, 그리고 포트번호가 완전히 일치하지 않을때, 두 윈도우간의 상호작용을 차단한다. 이것은 동일 출처 원칙(same origin policy)의 제약사항이며 출처가 다른 두 윈도우를 교차 출처(cross origin) 상태에 있다고 한다. 교차 출처인 윈도우의 변수나 함수 즉, 프로퍼티로의 접근은 대부분 차단된다고 생각하면 된다. 가령 A 윈도우에서 교차 출처인 B 윈도우의 주소를 Location을 통해 가져오려고 하면 DOMException이 발생하면서 스크립트가 중단되는 식이다. 참고로 교차 출처 상태일 때 location으로 주소를 알아낼 수는 없지만 주소를 바꿀 수는 있다. 하여간 이런 동일 출처 원칙의 제약을 우회할 수 있는게(비록 엄격한 조건 하에서만 가능하지만) 바로 Window.postMessage다.otherWindow.postMessage(message, targetOrigin, [transfer]); message: 다른 윈도우에 전달할 메시지 targetOrigin: 메시지를 전달할 윈도우의 출처를 명시한다. 대상 윈도우의 스킴, 호스트명, 포트번호가 targetOrigin에 명시된 것과 정확히 일치하지 않으면 메시지는 차단된다. transfer: Is a sequence of Transferable objects that are transferred with the message. The ownership of these objects is given to the destination side and they are no longer usable on the sending side. 아래는 교차 출처인 A 윈도우 http://tistory.com과 B 윈도우 https://secure.tistory.com이 서로 메시지를 주고받는 코드다. // B 윈도우에서 핸들러 설정function receiveBeginningMessage(event) &#123; if (event.origin !== \"http://tistory.com\") &#123; return; &#125; console.log(event.data); // A 윈도우에서 보낸 메시지 event.source.postMessage(\"my location is \" + location.href, event.origin);&#125;window.addEventListener(\"message\", receiveBeginningMessage); // A 윈도우에서 핸들러 설정function receiveReturnMessage(event) &#123; console.log(event.data); // B 윈도우에서 보낸 메시지&#125;window.addEventListener(\"message\", receiveReturnMessage); // A 윈도우에서 Window.postMessage 사용var child = frames[0];child.postMessage(\"whispering\", \"https://secure.tistory.com\"); 순서는 대략: 양쪽 윈도우에 메시지 이벤트 핸들러 등록 A 윈도우에서 Window.postMessage 호출 B 윈도우에서 메시지 이벤트가 발생하고 핸들러 작동. 이 때 로그로 A 윈도우가 보낸 message를 출력하고 A 윈도우로 메시지 이벤트를 발생시킴 A 윈도우에서 메시지 이벤트 핸들러 작동하며 B 윈도우가 보낸 메시지 출력","categories":[{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/categories/javascript/"}],"tags":[{"name":"ecmascript","slug":"ecmascript","permalink":"http://noritersand.github.io/tags/ecmascript/"},{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/tags/javascript/"},{"name":"windows","slug":"windows","permalink":"http://noritersand.github.io/tags/windows/"},{"name":"postMessage","slug":"postMessage","permalink":"http://noritersand.github.io/tags/postMessage/"}]},{"title":"JavaScript: Ajax","slug":"JavaScript-Ajax","date":"2018-03-20T08:08:18.000Z","updated":"2018-07-11T00:15:13.190Z","comments":true,"path":"javascript/JavaScript-Ajax/","link":"","permalink":"http://noritersand.github.io/javascript/JavaScript-Ajax/","excerpt":"","text":"참고한 글 https://xhr.spec.whatwg.org/ http://www.w3schools.com/ajax/ https://developer.mozilla.org/ko/docs/XMLHttpRequest https://developer.mozilla.org/en-US/docs/Web/API/XMLHttpRequest/Using_XMLHttpRequest http://huns.me/development/1291 Ajax란?Ajax는 ‘Asynchronous JavaScript and XML’의 약자로 웹 애플리케이션 개발 기법의 하나다. Ajax는 독립된 기술을 의미하기보단 여러 기술의 묶음을 지칭하는 용어에 가깝다. 실제로 Ajax를 구현하는 데는 HTML, CSS, DOM, 자바스크립트, XML, XSLT, XPath, XMLHttpRequest 등이 사용된다. Ajax를 사용하려면 먼저 브라우저의 내장 함수로 XMLHttpRequest 객체(의외지만 XMLHttpRequest는 마이크로소프트에서 처음 만들었다)를 생성해야 한다. 과거엔 ActiveXObject라는 소름 돋는 이름의 생성자를 사용했지만, 웹 사용자의 최소 환경이 IE8인 요즘엔 사용하지 않는다.var xmlReq = false;if (window.XMLHttpRequest) &#123; // Non-Microsoft browsers xmlReq = new XMLHttpRequest();&#125; else if (window.ActiveXObject) &#123; try &#123; xmlReq = new ActiveXObject('Msxml2.XMLHTTP'); // XMLHttpRequest in later versions of Internet Explorer &#125; catch (e1) &#123; try &#123; xmlReq = new ActiveXObject('Microsoft.XMLHTTP'); // Try version supported by older versions of Internet Explorer &#125; catch (e2) &#123; // Unable to create an XMLHttpRequest with ActiveX &#125; &#125;&#125; 마소가 폭주하던 2000년대에나 쓰이던 코드. 지금은 그냥 아래 한 줄로 해결된다:var xhr = new XMLHttpRequest(); 아래 두 예시를 각각 test1.html, test2.html로 만들어서 테스트 해보자:&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;meta charset=\"UTF-8\"&gt;&lt;title&gt;test1.html&lt;/title&gt;&lt;script&gt; function loadDoc() &#123; var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; document.getElementById('demo').innerHTML = xhr.responseText; &#125; &#125;; xhr.open('GET', 'test2.html'); xhr.send(); &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;button onclick=\"loadDoc()\"&gt;who r u&lt;/button&gt;&lt;div id=\"demo\"&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; &lt;h2&gt;i am waldo&lt;/h2&gt; XMLHttpRequest의 프로퍼티XMLHttpRequest.open()XMLHttpRequest.open( method, url [ , async ] ) method: HTTP 메서드 타입 (get/post) url: 서버 경로 async: 비동기 여부. (true/false) request의 유형을 지정한다. send()로 메시지를 날리기 전, 어디에 어떤 방식으로 작동하는지를 정하는 메서드. method와 url은 필수지만 async는 기본값이 true로 생략할 수 있는 항목이다. async를 false로 지정할 경우 send() 후 스크립트의 진행을 중단하며 서버로부터 응답이 올 때까지 대기한다.var xhr = new XMLHttpRequest();xhr.open('GET', 'test2.html');// GET 방식으로 요청할 URL 설정 XMLHttpRequest.setRequestHeader()XMLHttpRequest.setRequestHeader( header, value ) header: 헤더의 이름 value: 헤더의 값 HttpRequest 헤더의 값을 설정하는 메서드로 반드시 open()보다 나중에 호출되어야 한다. XMLHttpRequest.send()XMLHttpRequest.send( [ string ] ) string: 폼 데이터로 전송할 문자열 서버로 request 송신. open()에서 설정한 값에 따라 서버로 데이터를 요청한다. string은 HTTP 메서드 타입이 POST일 경우에만 명시하며 폼 데이터로 간주된다. POST 방식일 땐 아래 예시처럼 setRequestHeader()로 컨텐츠 타입을 지정하지 않으면 서버에서 처리할 수 없다. 그리고 string은 반드시 쿼리스트링 형태로 작성되어야 한다.var xhr = new XMLHttpRequest();xhr.open('POST', 'test4.html');xhr.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');xhr.send('first=111&amp;second=222'); XMLHttpRequest.abort()xhr.abort(); 수행 중인 통신을 중단한다. 이미 날라간 request는 어쩔 수 없고 단지 응답을 무시할 뿐. 통수 XMLHttpRequest.getAllResponseHeaders()response 헤더 정보를 출력한다. send()를 실행하기 전에는 빈 값을 리턴한다. 즉, 서버의 응답 후에만 사용 가능한 메서드xhr.getAllResponseHeaders();// \"Server: Apache-Coyote/1.1// Content-Type: text/html;charset=UTF-8// Content-Length: 22// Date: Wed, 27 Jan 2016 15:19:02 GMT// \" XMLHttpRequest.getResponseHeader()XMLHttpRequest.getResponseHeader( header ) header: 헤더의 이름 response 헤더 중 특정한 값만 리턴한다.xhr.getResponseHeader('Content-Type')// \"text/html;charset=UTF-8\" XMLHttpRequest.timeout지정한 시간을 초과하면 XMLHttpRequestEventTarget.ontimeout을 호출한다. 단위는 밀리초(milliseconds) XMLHttpRequest.responseText서버의 응답을 문자열로 리턴. XMLHttpRequest.responseXML서버의 응답을 XMLDocument로 파싱해 리턴. 파싱이 불가능하면 null을 리턴한다. XMLHttpRequest.status응답의 상태코드를 숫자로 리턴한다. XMLHttpRequest.statusText응답의 상태코드를 문자열로 리턴한다. 단순히 숫자를 문자열로 표현하는게 아니라 상태코드가 뭘 의미하는지 나타낸다. 가령 상태코드가 404일 때 리턴되는 값은 “Not Found” XMLHttpRequest.readyStateXMLHttpRequest의 현재 상태를 의미한다. 0: request not initialized. 1: server connection established 2: request received 3: processing request 4: request finished and response is ready Attach callback function통신 후 성공 혹은 실패에 따른 처리가 필요하다면 서버가 응답했을 때 콜백으로 호출되는 프로퍼티에 함수를 할당하면 된다. 콜백 함수를 할당하는 방법은 XMLHttpRequest의 onreadystatechange() 메서드를 이용하거나 XMLHttpRequestEventTarget의 이벤트 핸들러를 이용하는 방법, 그리고 EventTarget.addEventListener() 이용하는 방법이 있다. XMLHttpRequest.onreadystatechangevar xhr = new XMLHttpRequest();xhr.onreadystatechange = function() &#123; if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) &#123; console.log('complete'); &#125;&#125;;xhr.open('GET', 'http://somewhere');xhr.send(); onreadystatechange()는 XMLHttpRequest의 프로퍼티로 콜백 함수를 저장한다. 이 메서드는 readyState의 값이 변할 때마다 호출되니 그대로 실행되도록 하면 안 되고 readyState의 값을 체크하는 조건 분기를 추가해야 원하는 결과를 얻을 수 있다. EventTarget.addEventListener()EventTarget.addEventListener( eventType, callback ) eventType: callback이 실행될 이벤트의 유형 (ex: ‘load’) callback: eventType에 지정한 이벤트가 발생했을 때 실행할 함수 addEventListener()는 IE8에서 지원되지 않으니 주의할 것. 악의 축function reqListener () &#123; console.log(this.responseText); // this == xhr&#125;var xhr = new XMLHttpRequest();xhr.addEventListener('load', reqListener);xhr.open('GET', 'http://example.org/example.txt');xhr.send(); XMLHttpRequestEventTargetvar xhr = new XMLHttpRequest();console.debug(xhr);xhr.onabort = function() &#123; console.log('onabort - xhr.readyState: ' + xhr.readyState);&#125;;xhr.onerror = function() &#123; console.log('onerror - xhr.readyState: ' + xhr.readyState); console.log('xhr.status: ' + xhr.status);&#125;;xhr.onloadstart = function() &#123; console.log('onloadstart - xhr.readyState: ' + xhr.readyState);&#125;;xhr.onloadend = function() &#123; console.log('onloadend - xhr.readyState: ' + xhr.readyState);&#125;;xhr.onprogress = function(event) &#123; console.log('progress - xhr.readyState: ' + xhr.readyState); console.log('loaded: ' + event.loaded); console.log('size: ' + event.size);&#125;;xhr.onload = function() &#123; console.log('complete');&#125;;xhr.open('GET', 'test2.html');xhr.send(); XMLHttpRequestEventTarget은 XMLHttpRequest의 슈퍼클래스다. 상속받는 메서드는 다음과 같다: onabort: abort 이벤트가 발생하면 호출된다. onerror: 서버의 응답이 200이 아닐 때 호출된다. onloadstart: XHR 요청을 시작할 때 호출된다. onloadend: XHR 요청이 완료되면 호출된다. onload()와 다르게 성공/실패 상관없이 호출된다. onprogress: onloadstart()와 onloadend() 사이에 호출된다. 파라미터로 ProgressEvent를 전달받으며 이 객체의 프로퍼티는 브라우저마다 다를 수 있다. onload: XHR 요청이 ‘성공적으로’ 완료되면 호출된다. 즉 XHR.status가 200일 때만 호출되는 메서드. ontimeout: XHR.timeout으로 설정한 시간 내에 응답이 도착하지 않으면 호출된다. 요청은 실패한 것으로 간주되며 onprogress()와 onload()는 호출되지 않는다.","categories":[{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/categories/javascript/"}],"tags":[{"name":"ecmascript","slug":"ecmascript","permalink":"http://noritersand.github.io/tags/ecmascript/"},{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/tags/javascript/"},{"name":"ajax","slug":"ajax","permalink":"http://noritersand.github.io/tags/ajax/"},{"name":"xmlhttprequest","slug":"xmlhttprequest","permalink":"http://noritersand.github.io/tags/xmlhttprequest/"}]},{"title":"JavaScript: pseudo protocol 앵커(a) 태그로 스크립트 실행 시 주의사항","slug":"JavaScript-pseudo-protocol-앵커-a-태그로-스크립트-실행-시-주의사항","date":"2018-03-20T08:00:42.000Z","updated":"2018-07-11T00:15:13.193Z","comments":true,"path":"javascript/JavaScript-pseudo-protocol-앵커-a-태그로-스크립트-실행-시-주의사항/","link":"","permalink":"http://noritersand.github.io/javascript/JavaScript-pseudo-protocol-앵커-a-태그로-스크립트-실행-시-주의사항/","excerpt":"","text":"테스트 환경 explorer 10 chrome 43 firefox 38 opera 30 문서의 어느 한 요소를 클릭했을 때 지정한 함수를 호출하도록 HTML을 작성한다고 하자. 이럴 때 흔히들 &lt;a&gt; 태그의 href 속성을 이용하여 스크립트를 실행하곤 한다.&lt;a href=\"javascript:getSome()\"&gt; 눌러요 &lt;/a&gt; ‘javascript: pseudo protocol’ 혹은 그냥 ‘javascript protocol’, ‘javascript prefix’라고 하는 이 방식은 사실 &lt;a&gt; 태그의 매우 잘못된 사용법이다. 대신 &lt;button&gt; 태그와 onclick 속성의 조합이 권장되는데, 불가피하게 &lt;a&gt; 태그를 꼭 사용해야 한다면 최소한 아래 내용은 숙지하는게 좋다.&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;script&gt; function fn() &#123; console.log('hi'); return true; &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;a href=\"javascript:fn()\"&gt;pushme&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 위 코드를 브라우저로 열어서 &lt;a&gt; 태그를 클릭하면 무슨 일이 일어날까? 파이어폭스와 익스플로러는 앵커에 의해 스크립트가 실행될 때, 해당 스크립트가 리턴하는 undefined 이외의 값을 URL로 간주하는 경향이 있다. 위 스샷은 이 때문에 발생하는 현상이다. 에러라면 에러라고 할 수 있는 현상인데, 이를 방지하기 위해선 아래 방법 중 하나를 따른다. (크롬과 오페라는 해당 없음. 사파리는 패스) 함수가 undefined를 반환자바스크립트의 함수는 브레이스} 혹은 return을 만났을 때 undefined를 반환한다. 즉, 반환값을 명시하지 않는 방법이다.&lt;script&gt; function fn() &#123; console.log('hi'); &#125;&lt;/script&gt;&lt;a href=\"javascript:fn()\"&gt;pushme&lt;/a&gt; onclick=”return false”반환값을 정의할 수 없는 함수를 호출할 때 사용한다. (가령 거의 대부분 객체를 리턴하는 jQuery의 메서드들) 이러한 경우에 onclick 이벤트 핸들러가 false를 리턴하게 하여 브라우저의 기본동작을 막아버리는 방법이다. (이벤트 핸들러가 false를 리턴하면 태그의 기본동작과 이벤트 전파(버블링, 캡처링)를 차단하는 효과가 있다.)&lt;script&gt; function fn() &#123; console.log('hi'); return 'arrrrgh'; &#125;&lt;/script&gt;&lt;a href=\"javascript:fn()\" onclick=\"return false\"&gt;pushme&lt;/a&gt; void 연산자 사용void 연산자가 피연산자를 실행하되 피연산자의 값을 무시하고 무조건 undefined를 반환하는 특성을 이용한 방법이다.&lt;a href=\"javascript:void window.open()\"&gt;open&lt;/a&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/categories/javascript/"}],"tags":[{"name":"ecmascript","slug":"ecmascript","permalink":"http://noritersand.github.io/tags/ecmascript/"},{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/tags/javascript/"},{"name":"anchor","slug":"anchor","permalink":"http://noritersand.github.io/tags/anchor/"}]},{"title":"JavaScript: eval()과 new Function()의 차이","slug":"JavaScript-eval-과-new-Function-의-차이","date":"2018-03-20T07:58:02.000Z","updated":"2018-07-11T00:15:13.193Z","comments":true,"path":"javascript/JavaScript-eval-과-new-Function-의-차이/","link":"","permalink":"http://noritersand.github.io/javascript/JavaScript-eval-과-new-Function-의-차이/","excerpt":"","text":"참고한 글 http://stackoverflow.com/questions/4599857/are-eval-and-new-function-the-same-thing function test1() &#123; var a = 111; eval('console.debug(a); a = 222;'); // 111 console.debug(a); // 222&#125;test1();function test2() &#123; var b = 333; new Function('console.debug(b);')(); // ReferenceError: b is not defined&#125;test2(); 내부동작과 유효범위(혹은 scope)의 차이가 있다. eval(): 자바스크립트 표현식으로 문자열을 자바스크립트 코드로 해석한 후 이를 평가한다. 이 때 eval()을 호출하는 시점의 변수 환경이 사용하기 때문에 실행 범위 내의 지역변수에 접근 할 수 있다. new Function(): 주어진 문자열을 자바스크립트 코드로 파싱하여 호출 가능한 객체에 저장하며 별도의 함수 영역으로 분리되기 때문에 지역변수에 접근 할 수 없다.","categories":[{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/categories/javascript/"}],"tags":[{"name":"ecmascript","slug":"ecmascript","permalink":"http://noritersand.github.io/tags/ecmascript/"},{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/tags/javascript/"},{"name":"eval","slug":"eval","permalink":"http://noritersand.github.io/tags/eval/"}]},{"title":"JavaScript: 콜백 함수란 callback functions","slug":"JavaScript-콜백-함수란-callback-functions","date":"2018-03-20T07:54:14.000Z","updated":"2018-07-11T00:15:13.201Z","comments":true,"path":"javascript/JavaScript-콜백-함수란-callback-functions/","link":"","permalink":"http://noritersand.github.io/javascript/JavaScript-콜백-함수란-callback-functions/","excerpt":"","text":"자바스크립트의 함수(function)는 하나의 완성된 객체다. 클래스에 종속적이며 클래스 없이는 접근이 불가능한 자바의 메서드(method)와는 다르다. 자바의 메서드가 단지 인스턴스화 될 클래스의 템플릿으로 존재하는 반면, 함수는 독립적인 객체로 존재하기 때문에 함수만으로 접근이 가능하고 개별선언도 가능하다.하여간 이러한 특징 덕분에 자바에서는 상상도 못할일이 자바스크립트에선 가능한데… 그건 바로 파라미터로 함수 객체를 전달하는 것. 요딴 식이다:function say(word) &#123; console.log(word);&#125;function execute(someFunction, value) &#123; someFunction(value);&#125;execute(say, \"Hello\"); 코드 출처 - manuel kiessling의 ‘The Node Beginner Book’ 다음의 더욱 해괴한 코드를 보면:function execute(someFunction, value) &#123; someFunction(value);&#125;execute(function(word) &#123; console.log(word)&#125;, \"Hello\"); 이 코드는 사실 맨 처음 예를 든 코드의 단축형이다. ③ execute ( ①익명함수, ②파라미터 ); 3을 호출하는데 1을 첫번째 파라미터로 넘겨준다. 그런데 여기서 첫번째 파라미터는 함수 리터럴, 함수의 정의부분이다. 즉, 뭔가 작동을 해야할 몸체는 아직 아무것도 없다. 그리고 두번째 파라미터 2를 넘겨준다. execute는 전달받은 첫번째 파라미터를 실행하는데 그것은 함수다. 그리고 두번째 파라미터를, 첫번째 파라미터(함수객체)의 매개변수로 전달한다.var http = require(\"http\");http.createServer(function(request, response) &#123; response.writeHead(200, &#123;\"Content-Type\": \"text/plain\"&#125;); response.write(\"Hello World\"); response.end();&#125;).listen(8888); 위에서 두번째로 예를 든 코드와 다를바가 없다. 아주 약간 복잡한 함수가 api로 제공될 뿐이다.createServer()는 첫 번째 파라미터로 함수를 받는다. 그리고 createServer() 메서드가 리턴한 객체의 listen() 함수로 http 리스너를 등록한다. 그리곤 request 이벤트가 발생할때마다 첫 번째 파라미터인 리터럴로 작성한 함수가 실행된다.","categories":[{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/categories/javascript/"}],"tags":[{"name":"ecmascript","slug":"ecmascript","permalink":"http://noritersand.github.io/tags/ecmascript/"},{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/tags/javascript/"},{"name":"callback","slug":"callback","permalink":"http://noritersand.github.io/tags/callback/"}]},{"title":"JavaScript: 클로저 closures","slug":"JavaScript-클로저-closures","date":"2018-03-20T07:46:26.000Z","updated":"2018-07-11T00:15:13.202Z","comments":true,"path":"javascript/JavaScript-클로저-closures/","link":"","permalink":"http://noritersand.github.io/javascript/JavaScript-클로저-closures/","excerpt":"","text":"참고한 글 https://developer.mozilla.org/ko/docs/Web/JavaScript/Guide/Closures https://opentutorials.org/course/743/6544 http://www.insightbook.co.kr/book/programming-insight/자바스크립트-완벽-가이드 클로저란? 대다수의 현대 프로그래밍 언어와 마찬가지로 자바스크립트 또한 어휘적 유효범위(Lexical scoping)을 사용한다. 이는 함수를 호출하는 시점에서의 변수 유효범위가 아니라, 함수가 정의되었을 때의 변수 유효범위를 사용하여 함수가 실행된다는 뜻이다. 이러한 어휘적 유효범위를 구현하기 위해, 자바스크립트 함수객체는 내부 상태에 함수 자체의 코드뿐만 아니라 현재 유효범위 체인에 대한 참조도 포함하고 있다. 함수 객체와 함수의 변수가 해석되는 범위(변수 바인딩의 집합)의 조합은 컴퓨터 과학 문헌에서 클로저(closure)1라고 일컫는다2. 1: 이는 함수의 변수가 유효범위 체인에 바인딩되어 있고, 따라서 그 함수는 함수의 변수에 ‘따라 닫힌다’는 뜻에서 유래한 용어다. 2: (역자주) 함수 내에서 선언된 변수는 보통 함수의 실행이 끝나면 같이 소멸해야 한다. 하지만, 함수의 실행이 끝나더라도 유효범위 체인 상에서 함수 내의 변수가 계속 살아있어야 하는 상황이라면, 내부 변수가 살아있으므로 그 함수는 ‘닫힐’ 수 없다. 해당 함수가 완전히 ‘닫힐’ 수 있는 경우는 함수 내에서 정의한 변수들을 참조하는 곳이 없어야 하는 상황이므로, 함수의 닫힘 가능 여부는 해당 함수의 실행 종료 여부가 아니라 변수 유효 여부에 달린 것이다. 출처: 자바스크립트 완벽가이드 (JavaScript the definitive guide 6/E), David Flanagan 간단히 말해서 함수 객체나 함수 내의 변수가 유효범위를 벗어나도 참조가 유지되는 한 소멸하지 않는 환경 혹은 그러한 함수가 클로저다.function outer() &#123; var a = 'still alive'; function inner() &#123; console.log(a); &#125; return inner;&#125;var inner = outer();inner(); // 'still alive', inner 함수의 참조가 종료될 때까지 a도 소멸하지 않는다. 클로저인가 클로져인가?closure [klóuʒər] 국립국어원은 “마찰음Ʒ와 파찰음dʒ, ts, dz, t∫가 모음 앞에 올 때에는 ‘지, 치’가 아니라 ‘ㅈ, ㅊ’으로 적으므로 항상 ‘자, 저, 조, 주’, ‘차, 처, 초, 추’로 표기”라고 한다. 따라서 클로저가 올바른 표기법. 이에 따르면 우리가 알고 있는 ‘피카츄’도 올바른 표기법이 아니다. ‘피카추’가 맞다. (…)","categories":[{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/categories/javascript/"}],"tags":[{"name":"ecmascript","slug":"ecmascript","permalink":"http://noritersand.github.io/tags/ecmascript/"},{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/tags/javascript/"},{"name":"closures","slug":"closures","permalink":"http://noritersand.github.io/tags/closures/"}]},{"title":"JavaScript: 비정형 인자 arguments","slug":"JavaScript-비정형-인자-arguments","date":"2018-03-20T07:45:07.000Z","updated":"2018-07-11T00:15:13.197Z","comments":true,"path":"javascript/JavaScript-비정형-인자-arguments/","link":"","permalink":"http://noritersand.github.io/javascript/JavaScript-비정형-인자-arguments/","excerpt":"","text":"자바스크립트에는 선언부에 명시되지 않은 파라미터를 별도로 저장하는 프로퍼티가 존재한다.function argsTest() &#123; // ... 생략 arguments[2]; // 'arg3'&#125;argsTest('arg1', 'arg2', 'arg3'); 위의 argsTest() 호출 시 전달된 세 개의 문자열은 배열로 생성되며 arguments 프로퍼티를 통해 접근한다.function argsTest() &#123; if (arguments.length &lt; 1) &#123; throw new Error('usage: argsTest(url, 파라미터1, 파라미터2, ...)'); &#125; for (var i = 0; i &lt; arguments.length; i++) &#123; if (i != 1 &amp;&amp; typeof arguments[i] != 'string') &#123; alert('argsTest()의 인수는 문자열만 가능합니다.'); return; &#125; &#125;&#125;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/categories/javascript/"}],"tags":[{"name":"ecmascript","slug":"ecmascript","permalink":"http://noritersand.github.io/tags/ecmascript/"},{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/tags/javascript/"},{"name":"arguments","slug":"arguments","permalink":"http://noritersand.github.io/tags/arguments/"}]},{"title":"JavaScript: with, debugger","slug":"JavaScript-with-debugger","date":"2018-03-20T07:43:07.000Z","updated":"2018-07-11T00:15:13.194Z","comments":true,"path":"javascript/JavaScript-with-debugger/","link":"","permalink":"http://noritersand.github.io/javascript/JavaScript-with-debugger/","excerpt":"","text":"참고한 글 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/with with주로 깊이 중첩된 구조를 갖는 객체의 프로퍼티 접근 표현식을 생략하기 위해 사용된다. 다만 사용이 권장되지 않는다. David Flanagan은 최적화가 힘들고 코드 실행 속도가 느리기 때문이라 한다. MDN은 “혼란스러운 버그를 유발하고 호환성에 문제가 있어서 비권장”한다. 게다가 엄격 모드(strict mode)에선 사용조차 불가하니 실제 쓸 일은 없어 보인다.var obj = &#123;&#125;;obj.inner = &#123;&#125;;obj.inner.number = 1234;with (obj.inner) &#123; console.debug(number); // 1234&#125; debugger디버거의 브레이크 포인트 역할을 하는 키워드. 실제로 사용해보면 debugger 키워드가 있는 지점에 브레이크가 걸린다. 단 실제 작동은 자바스크립트 구현체에 따라 달라질 수 있다. 인터넷 브라우저에선 크롬51, 파폭47, IE11, 엣지에서 정상 작동하는걸 확인함. 브라우저 개발자 도구를 열어놓고 아래 코드를 실행해보자:var str = 'debugger test';function fn() &#123; debugger; return str;&#125;fn();","categories":[{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/categories/javascript/"}],"tags":[{"name":"ecmascript","slug":"ecmascript","permalink":"http://noritersand.github.io/tags/ecmascript/"},{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/tags/javascript/"},{"name":"with","slug":"with","permalink":"http://noritersand.github.io/tags/with/"},{"name":"debugger","slug":"debugger","permalink":"http://noritersand.github.io/tags/debugger/"}]},{"title":"JavaScript: const, let","slug":"JavaScript-const-let","date":"2018-03-20T07:40:10.000Z","updated":"2018-07-11T00:15:13.192Z","comments":true,"path":"javascript/JavaScript-const-let/","link":"","permalink":"http://noritersand.github.io/javascript/JavaScript-const-let/","excerpt":"","text":"참고한 글 https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Statements/const 테스트 환경 파이어폭스 47.0 constconst는 자바스크립트 1.5 이후 버전에서 사용가능한 키워드로, 상수를 정의할 때 사용하며 var 키워드를 대체할 수 있다.const name1 = value1 [, name2 = value2 [, ... [, nameN = valueN]]]; const PI = 3.14; const는 전형적인 ‘상수’답게 선언 시점에 반드시 초기화되어야 하며 선언 이후의 할당은 무시되거나 에러를 발생시킨다.const ABC; // SyntaxError: missing = in const declaration, 초기화 필요함const PI = 3.14; // 정상적인 선언const PI = 3.14159265; // SyntaxError: redeclaration of const PI, 중복 선언 불가PI = 3.141592; // TypeError: invalid assignment to const `PI', 재할당 불가var PI = 3; // SyntaxError: redeclaration of const PI, 같은 이름의 변수 선언 불가 const는 객체 선언에도 사용할 수 있으나 객체의 프로퍼티는 보호되지 않는다:const MY_OBJECT = &#123;\"key\": \"value\"&#125;;MY_OBJECT = &#123;\"OTHER_KEY\": \"value\"&#125;; // SyntaxError: redeclaration of const MY_OBJECTMY_OBJECT.key = \"otherValue\";console.debug(MY_OBJECT); // Object &#123; key: \"otherValue\" &#125; 객체를 완전히 보호하고 싶다면 Object.freeze()를 사용할 것. letlet은 자바스크립트 1.7(ES2015)부터 신규 추가된 키워드다. const와 마찬가지로 var를 대체할 수 있다.let var1 [= value1] [, var2 [= value2]] [, ..., varN [= valueN]]; let은 자바스크립트의 변수가 갖는 함수 유효범위를 블록 유효범위로 제한하기 위해 사용한다.가령 다음의 경우:function fn() &#123; let a = 1; &#123; let b = 2; var w = 102; &#125; console.debug(a); // 1 console.debug(w); // 102 console.debug(b); // ReferenceError: b is not defined&#125;fn(); 유효범위가 함수 단위인 var를 사용한 변수 w는 블록 밖에서도 참조 가능한 반면, let을 사용하여 선언된 변수는 해당 지역을 감싼 블록과 그 하위의 중첩 블록에서만 유효한 블록 단위의 유효범위를 갖기 때문에 블록을 벗어난 지역에서는 참조 에러가 발생한다. 이를 활용하면 제어문의 표현식 내에서 생성된 변수의 유효범위를 해당 제어문 내로 제한할 수 있다. 예를 들어:var arr = ['a', 'b', 'c'];for (var ele1 in arr) &#123;&#125;console.debug(arr[ele1]); // 'c'for (let ele2 in arr) &#123;&#125;console.debug(arr[ele2]); // ReferenceError: ele2 is not defined let으로 선언된 ele2는 for문 밖에서 참조할 수 없다. IE는 11과 edge에서만 사용 가능 https://msdn.microsoft.com/en-us/library/s4esdbwz(v=vs.94).aspx","categories":[{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/categories/javascript/"}],"tags":[{"name":"ecmascript","slug":"ecmascript","permalink":"http://noritersand.github.io/tags/ecmascript/"},{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/tags/javascript/"},{"name":"const","slug":"const","permalink":"http://noritersand.github.io/tags/const/"},{"name":"let","slug":"let","permalink":"http://noritersand.github.io/tags/let/"}]},{"title":"JavaScript: 쿠키 컨트롤","slug":"JavaScript-쿠키-컨트롤","date":"2018-03-20T07:36:55.000Z","updated":"2018-07-11T00:15:13.202Z","comments":true,"path":"javascript/JavaScript-쿠키-컨트롤/","link":"","permalink":"http://noritersand.github.io/javascript/JavaScript-쿠키-컨트롤/","excerpt":"","text":"참고한 글 http://www.w3schools.com/js/js_cookies.asp https://developer.mozilla.org/en-US/docs/Web/API/Document/cookie document.cookiedocument.cookie = \"cookiename=value;\"document.cookie = \"cookiename=value; path=/;\"document.cookie = \"cookiename=value; path=/; expires=\" + new Date() // 생성과 동시에 만료된다. 즉 삭제document.cookie = \"cookiename=value; path=/; expires=0; domain=.tistory.com\"document.cookie = \"cookiename=value; secure\" // HTTPS 전송만 가능 expires: 쿠키의 만료시간을 의미한다. 명시하지 않거나 잘못된 값을 입력하면 세션쿠키로 생성되서 브라우저 종료 시 삭제된다. domain: 서버 이름에 따라 쿠키 사용여부가 결정된다. .tistory.com 처럼 메인 도메인명을 지정하면 a.tistory.com, b.tistory.com과 같이 서브 도메인이 달라도 쿠키를 공유한다. 명시하지 않으면 현재 페이지의 location.host값으로 설정된다. path: 서버 이름 뒤에 오는 경로에 따라 쿠키 사용여부가 결정된다. 슬래쉬( / )로 설정하면 모든 path에서 공유한다. 명시하지 않으면 현재 페이지의 location.path값으로 설정된다. secure: SSL 통신에서만 사용가능한 쿠키가 생성된다. HTTP 문서에서는 접근할 수 없다. 이 옵션을 활성화하지 않는한 HTTP/HTTPS 어느쪽에서 생성한 쿠키든 서로 공유한다. 주의사항쿠키의 값에는 쉼표,와 세미콜론;을 포함하면 안된다.http://stackoverflow.com/questions/25387340/is-comma-a-valid-character-in-cookie-value examplesfunction setCookie(cname, cvalue, exdays) &#123; var d = new Date(); d.setTime(d.getTime() + (exdays * 24 * 60 * 60 * 1000)); var expires = \"expires=\"+d.toUTCString(); document.cookie = cname + \"=\" + cvalue + \"; \" + expires;&#125;function getCookie(cname) &#123; var name = cname + \"=\"; var ca = document.cookie.split(';'); for (var i = 0; i &lt; ca.length; i++) &#123; var c = ca[i]; while (c.charAt(0)==' ') c = c.substring(1); if (c.indexOf(name) == 0) return c.substring(name.length, c.length); &#125; return \"\";&#125;function checkCookie() &#123; var user = getCookie(\"username\"); if (user != \"\") &#123; alert(\"Welcome again \" + user); &#125; else &#123; user = prompt(\"Please enter your name:\", \"\"); if (user != \"\" &amp;&amp; user != null) &#123; setCookie(\"username\", user, 365); &#125; &#125;&#125; /*\\|*||*| :: cookies.js ::|*||*| A complete cookies reader/writer framework with full unicode support.|*||*| Revision #1 - September 4, 2014|*||*| https://developer.mozilla.org/en-US/docs/Web/API/document.cookie|*| https://developer.mozilla.org/User:fusionchess|*||*| This framework is released under the GNU Public License, version 3 or later.|*| http://www.gnu.org/licenses/gpl-3.0-standalone.html|*||*| Syntaxes:|*||*| * docCookies.setItem(name, value[, end[, path[, domain[, secure]]]])|*| * docCookies.getItem(name)|*| * docCookies.removeItem(name[, path[, domain]])|*| * docCookies.hasItem(name)|*| * docCookies.keys()|*|\\*/var docCookies = &#123; getItem: function (sKey) &#123; if (!sKey) &#123; return null; &#125; return decodeURIComponent(document.cookie.replace(new RegExp(\"(?:(?:^|.*;)\\\\s*\" + encodeURIComponent(sKey).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&amp;\") + \"\\\\s*\\\\=\\\\s*([^;]*).*$)|^.*$\"), \"$1\")) || null; &#125;, setItem: function (sKey, sValue, vEnd, sPath, sDomain, bSecure) &#123; if (!sKey || /^(?:expires|max\\-age|path|domain|secure)$/i.test(sKey)) &#123; return false; &#125; var sExpires = \"\"; if (vEnd) &#123; switch (vEnd.constructor) &#123; case Number: sExpires = vEnd === Infinity ? \"; expires=Fri, 31 Dec 9999 23:59:59 GMT\" : \"; max-age=\" + vEnd; break; case String: sExpires = \"; expires=\" + vEnd; break; case Date: sExpires = \"; expires=\" + vEnd.toUTCString(); break; &#125; &#125; document.cookie = encodeURIComponent(sKey) + \"=\" + encodeURIComponent(sValue) + sExpires + (sDomain ? \"; domain=\" + sDomain : \"\") + (sPath ? \"; path=\" + sPath : \"\") + (bSecure ? \"; secure\" : \"\"); return true; &#125;, removeItem: function (sKey, sPath, sDomain) &#123; if (!this.hasItem(sKey)) &#123; return false; &#125; document.cookie = encodeURIComponent(sKey) + \"=; expires=Thu, 01 Jan 1970 00:00:00 GMT\" + (sDomain ? \"; domain=\" + sDomain : \"\") + (sPath ? \"; path=\" + sPath : \"\"); return true; &#125;, hasItem: function (sKey) &#123; if (!sKey) &#123; return false; &#125; return (new RegExp(\"(?:^|;\\\\s*)\" + encodeURIComponent(sKey).replace(/[\\-\\.\\+\\*]/g, \"\\\\$&amp;\") + \"\\\\s*\\\\=\")).test(document.cookie); &#125;, keys: function () &#123; var aKeys = document.cookie.replace(/((?:^|\\s*;)[^\\=]+)(?=;|$)|^\\s*|\\s*(?:\\=[^;]*)?(?:\\1|$)/g, \"\") .split(/\\s*(?:\\=[^;]*)?;\\s*/); for (var nLen = aKeys.length, nIdx = 0; nIdx &lt; nLen; nIdx++) &#123; aKeys[nIdx] = decodeURIComponent(aKeys[nIdx]); &#125; return aKeys; &#125;&#125;;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/categories/javascript/"}],"tags":[{"name":"ecmascript","slug":"ecmascript","permalink":"http://noritersand.github.io/tags/ecmascript/"},{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/tags/javascript/"},{"name":"cookie","slug":"cookie","permalink":"http://noritersand.github.io/tags/cookie/"}]},{"title":"JavaScript: 엄격 모드 strict mode","slug":"JavaScript-엄격-모드-strict-mode","date":"2018-03-20T07:24:15.000Z","updated":"2018-07-11T00:15:13.198Z","comments":true,"path":"javascript/JavaScript-엄격-모드-strict-mode/","link":"","permalink":"http://noritersand.github.io/javascript/JavaScript-엄격-모드-strict-mode/","excerpt":"","text":"참고한 글 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode http://www.w3schools.com/js/js_strict.asp http://www.insightbook.co.kr/book/programming-insight/자바스크립트-완벽-가이드 테스트 환경 파이어 폭스 47 크롬 51 엄격 모드란?‘strict mode(이하 엄격 모드)’는 ECMAScript 5부터 새로 추가된 기능이다. 스크립트의 시작 부분이나 함수 코드 블록의 시작부분에 use strict를 작성하는 것으로 엄격 모드임을 지시한다. 엄격 모드가 아닌 지역은 ‘표준 모드’로 구분된다. (표준 모드는 ‘non-strict’, ‘sloppy mode’라고도 함.)function test() &#123; 'use strict'; // 이 함수는 엄격 모드가 적용됨.&#125;// 스크립트 시작 부분에 지시어가 없으면 엄격 모드가 적용되지 않음. use strict를 함수 머리에 작성하면 엄격 모드의 적용 범위는 해당 함수로 제한된다. 위의 경우 최상위 스코프는 엄격 모드가 적용되지 않는다. 표준 모드: 살짝 문제가 있지만… 그냥 넘어가지 뭐.엄격 모드: 응 에러 엄격 모드의 가장 큰 특징은 ‘잘못된 구문(bad syntax)’을 어물쩡 넘어가지 않는다는 것이다. 표준 모드는 비록 잘못된 구문이 있더라도 정말 심각한 오류가 아니라면 알아서 보완하거나 단지 false를 반환하는 것으로 그치는데 비해, 엄격 모드에선 잘못된 구문을 항상 에러로 내뱉는다. 에러가 발생했으니 남은 코드의 실행이 중단되는 것은 덤. 엄격 모드에서 에러가 발생하는 잘못된 구문들아래는 표준 모드에서도 문제가 있거나 실패하는 구문이지만 에러가 발생하지는 않던 구문들이다. 엄격 모드에선 에러가 발생한다. var로 선언된 변수와 함수 선언문으로 생성된 함수, 함수의 파라미터 삭제 불가단순히 실패만 하던 삭제 시도는 이제 에러가 발생한다.function deleteParameter(param) &#123; 'use strict'; delete param; // SyntaxError: applying the 'delete' operator to an unqualified name is deprecated&#125;deleteParameter;function deleteFunctionObject(arg) &#123; 'use strict'; function aaa() &#123;&#125; delete aaa; // SyntaxError: applying the 'delete' operator to an unqualified name is deprecated&#125;deleteFunctionObject();function deleteVariable(arg) &#123; 'use strict'; var a = 123; delete a; // SyntaxError: applying the 'delete' operator to an unqualified name is deprecated&#125;deleteVariable(); non-extensible/non-writable/non-configurablenon-extensible 객체에 프로퍼티를 추가할 때와 non-writable 프로퍼티의 값을 변경할 때, non-configurable 프로퍼티를 지우려고 할 때 타입 에러가 발생한다.function nonextensible() &#123; 'use strict'; var obj = &#123;&#125;; Object.preventExtensions(obj); obj.a = 123; // TypeError: can't define property \"a\": Object is not extensible&#125;nonextensible();function nonwritable() &#123; 'use strict'; var obj = &#123;&#125;; Object.defineProperty(obj, 'a', &#123; value: 123, writable: false &#125;); obj.a = 456; // TypeError: \"a\" is read-only&#125;nonwritable();function nonconfigurable() &#123; 'use strict'; var obj = &#123;&#125;; Object.defineProperty(obj, 'a', &#123; value: 1, configurable: false &#125;); delete obj.a; // TypeError: property \"a\" is non-configurable and can't be deleted&#125;nonconfigurable(); 객체 리터럴에 같은 이름의 프로퍼티 중복 불가ES2015(ES6)에서 허용됨. 함수에 동일한 이름의 파라미터가 존재할 수 없음function strict(param, param) &#123; // SyntaxError: Duplicate parameter name not allowed in this context 'use strict';&#125; getter만 있고 setter가 없는 객체의 프로퍼티에 값 할당 불가// 'use strict';var obj = &#123; get x() &#123; return 0 &#125;&#125;;obj.x = 123; // TypeError: setting a property that has only a getter 원시 타입의 래퍼 객체에 프로퍼티 추가 불가원시 타입이 변환된 래퍼 객체에 프로퍼티를 추가하거나 기존 프로퍼티의 값을 바꾸는 것은 불가능하며 타입 에러가 발생한다.'use strict';false.true = ''; // TypeError: can't assign to properties of (new Boolean(false)): not an object(14).sailing = 'home'; // TypeError: can't assign to properties of (new Number(14)): not an object'BBK'.include = 'MB'; // TypeError: can't assign to properties of (new String(\"BBK\")): not an object 엄격 모드에서 다르게 작동하는 구문들아래는 표준 모드와 다르게 작동하는 구문들이다. 엄격 모드에서 사용이 금지되거나 허용되지 않는 것도 포함한다. 암시적 변수 선언모든 변수는 선언되지 않고 사용할 수 없다. 표준 모드에선 var 키워드 없이 생성된 변수는 마치 전역 변수인 것처럼 자동으로 생성되고 사용할 수 있었지만 엄격 모드에서는 허용되지 않는다.'use strict';obj = &#123;&#125;; // ReferenceError: assignment to undeclared variable obj with문 사용불가유효 범위 체인을 변경하는 with문은 엄격 모드에서 사용할 수 없다.(function() &#123; 'use strict'; with (Math) &#123; // ... &#125;&#125;)(); // SyntaxError: strict mode code may not contain 'with' statements this의 변화함수가 메서드가 아닌 함수로 호출될 때 this는 undefined가 된다(표준 모드에선 함수로 호출될 때의 this는 전역 객체다). 이를 이용하면 엄격 모드 지원 여부를 판단할 수 있다.var supportStrictMode = (function() &#123; 'use strict'; return this === undefined;&#125;)();console.debug(supportStrictMode); 그리고 함수가 call()이나 apply()로 호출될 때 this의 값은 호출표현식의 첫 번째 인자값이다. 표준 모드에선 첫 번째 인자가 원시 타입이면 this는 래퍼 객체가 된다.function standard(arg) &#123; console.debug(this); // Number &#123; 123 &#125; console.debug(typeof this); // object&#125;standard.call(123);function strict(arg) &#123; 'use strict'; console.debug(this); // 123 console.debug(typeof this); // number&#125;strict.call(123); eval() 함수의 유효범위엄격 모드에서 eval() 함수는 함수 안의 중첩된 유효 범위로 취급된다. 때문에 eval()의 전달인자에 의해 생성된 변수나 함수가 있다면 이것은 eval() 내에서만 존재하게 된다.'use strict';eval('function a() &#123; console.debug(123); &#125;');a(); // ReferenceError: a is not defined arguments 객체의 분리표준 모드에선 arguments의 원소와 함수의 파라미터의 참조값이 같다. 엄격 모드에선 이 둘이 분리된다.function standard(param) &#123; param = 1; console.log(arguments[0]); // 1&#125;standard(123);function strict(param) &#123; 'use strict'; param = 1; console.log(arguments[0]); // 123&#125;strict(123); 8진수 리터럴 사용 불가'use strict';console.debug(010); // SyntaxError: octal literals and octal escape sequences are deprecated 함수의 프로퍼티인 arguments, caller, callee에 접근 불가'use strict';function fn() &#123; 'use strict'; return arguments.callee;&#125;;fn(); // TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to themfn.caller; // TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to themfn.arguments; // TypeError: 'caller', 'callee', and 'arguments' properties may not be accessed on strict mode functions or the arguments objects for calls to them eval과 arguments는 키워드로 취급됨키워드는 식별자로 사용할 수 없음.'use strict';var eval = 123; // SyntaxError: redefining eval is deprecatedvar arguments = 123; // SyntaxError: redefining arguments is deprecated 엄격 모드에서 사용할 수 없는 예약어들다음 목록은 키워드로 예약되어 있어서 식별자로 사용할 수 없다. (변수, 함수, 파라미터, 레이블의 이름으로 사용 불가) implements interface let package private protected public static yield","categories":[{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/categories/javascript/"}],"tags":[{"name":"ecmascript","slug":"ecmascript","permalink":"http://noritersand.github.io/tags/ecmascript/"},{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/tags/javascript/"},{"name":"strict mode","slug":"strict-mode","permalink":"http://noritersand.github.io/tags/strict-mode/"}]},{"title":"JavaScript: 타입 변환 type conversion","slug":"JavaScript-타입-변환-type-conversion","date":"2018-03-20T07:15:11.000Z","updated":"2018-07-11T00:15:13.203Z","comments":true,"path":"javascript/JavaScript-타입-변환-type-conversion/","link":"","permalink":"http://noritersand.github.io/javascript/JavaScript-타입-변환-type-conversion/","excerpt":"","text":"참고한 글 http://www.insightbook.co.kr/book/programming-insight/자바스크립트-완벽-가이드 암시적 타입 변환자바스크립트는 필요에 따라 타입 변환을 자동으로 수행한다. 가령 문자열이 필요한 위치에 할당된 값이 문자열이 아니면 문자열 타입으로 변환을 시도할 것이다. 이 과정에서 타입이 올바르지 않아 에러가 발생하는 경우는 거의 없다. 다음은 암시적 타입 변환의 사례들이다:if (1) &#123; console.log('1 is true');&#125;if (!'') &#123; console.log('null string is false');&#125;if ('false') &#123; console.log('\"false\" is true');&#125; if문의 조건으로 불리언이 아닌 값이 할당되면 이 값은 불리언 타입으로 변환된다.var a = 1;a = a + '';typeof a; // \"string\"typeof +a; // \"number\"var b = \"2\";typeof b++; // \"number\"var c = \"xxx\";-c; // NaNc++; // NaN 산술 연산자 +는 피연산자가 문자열일 때 다른 피연산자를 문자열로 변환한다. +가 단항 연산자로 사용되면 피연산자를 숫자로 변환한다. 단항 연산자 -와 증감 연사자 --, ++의 암시적 변환도 동일하게 작동한다. 만약 숫자로 변환할 수 없는 문자열이면 NaN으로 변환된다.1 == \"1\"; // \"1\"은 1로 변환true == 1; // true는 1로 변환false == 0; // false는 0으로 변환\"1\" == true; // \"1\"은 true로 변환['a'] == 'a'; // 객체는 toString()이나 valueOf()를 사용해 문자열로 변환 동등 연산자 ==는 피연산자들이 서로 타입이 다를 때 타입 변환을 시도한다.규칙은 다음과 같다: 둘 중 하나가 숫자이고 나머지 하나가 문자열일 때 문자열을 숫자로 변환한다. 둘 중 하나가 불리언이고 나머지 하나가 숫자일 때 불리언을 숫자로 변환한다. 둘 중 하나가 문자열이고 나머지 하나가 불리언일 때 문자열을 불리언으로 변환한다. 둘 중 하나가 객체고 나머지 하나가 숫자 또는 문자열이면 객체를 문자열로 변환한다. 이 때 해당 객체의 toString()이나 valueOf()가 사용된다. 명시적 타입 변환Boolean('abcd'); // trueString(123); // \"123\"String(true); // \"true\"Number('123'); // 123Number('a123'); // NaNObject(123); // new Number(123)과 같다. 자동으로 수행되는 타입 변환 말고도 명시적인 타입 변환이 필요할 수 있다. 원시 타입으로의 변환을 원할 경우엔 단순히 Boolean(), Number(), String(), Object() 함수를 사용하면 된다.Boolean(&#123; a: 1 &#125;); // true, 객체는 모두 true로 변환된다. 객체를 불리언으로 변환할 때는 단 하나의 규칙만 기억하면 된다: 객체는 무조건 true다.var obj = &#123; a: 1, b: 2 &#125;;String(obj); // [object Object]var arr = [1, 2, 3];String(arr); // \"1,2,3\"function fn() &#123; console.log('do something'); &#125;String(fn); // \"function fn() &#123; console.log('do something');&#125;\"String(/D/g); // \"\"/D/g\"String(new Date()); // \"Thu Jul 07 2016 15:32:36 GMT+0900\" 객체를 문자열로 변환하려고 할 때 객체가 toString() 메서드를 갖고 있다면 자바스크립트는 이 메서드를 호출할 것이다. 만약 toString()을 갖고 있지 않거나 원시 타입을 반환하지 않으면 toString() 대신 valueOf()를 찾는다. valueOf()가 원시 타입을 반환하면 이 값을 문자열로 변환하겠지만 만약 valueOf()가 없거나 원시 타입을 반환하지 않으면 TypeError가 발생한다.Number([]); // 0Number([1]); // 1Number([1, 2]); // NaN 객체를 숫자로 변환할 땐 문자열과 반대로 valueOf()를 먼저 찾는다. valueOf()가 있고 원시 타입을 반환하면 이 값을 숫자로 변환하여 돌려준다. valueOf()가 없거나 원시 타입을 반환하지 않으면 자바스크립트는 toString()을 찾으며 같은 작업을 수행한다. 만약 toString()이 없거나 원시 타입을 반환하지 않으면 TypeError가 발생할 것이다.\"abcdef\".valueOf(); // \"abcdef\"/D/g.valueOf(); // /D/gnew Date().valueOf(); // 1467874589125, 1970-01-01 부터 지난 시간을 밀리초로 표현한 값 valueOf() 메서드는 오직 래퍼 객체와 정규식, Date 타입에서만 의미 있다. 기본적으로 valueOf()는 원시 타입으로 변환된 값을 돌려주도록 되어 있는데 대부분의 객체가 원시 타입으로 변환될 수 없으므로 단지 자기 자신(객체 자체)을 돌려줄 뿐이다. 빈 배열이 숫자 0으로 변환되는 것은 이런 특성탓이라 설명할 수 있다.Array 타입은 valueOf() 대신 toString()을 호출한다(규칙에 따라 valueOf()를 먼저 찾았으나 원시 타입이 아닌 객체를 돌려주므로 toString()을 대신 호출하는 것). toString()은 빈 배열을 빈 문자열로 돌려주며 빈 문자열을 숫자로 바꾸면 0이 되는 것이다. 자바스크립트 타입 변환 표출처: JavasScript: The Definitive Guide. David Flanagan 저. 6판. 58쪽 String Number Boolean Object undefined “undefined” NaN false TypeError null “null” 0 false TypeError true “true” 1 new Boolean(true) false “false” 0 new Boolean(false) “” (null-string) 0 false new String(“”) “1.2” 1.2 true new String(“1.2”) “one” NaN true new String(“one”) “ “ 0 true new String(“ “) 0 “0” false new Number(0) -0 “0” false new Number(-0) NaN “NaN” false new Number(NaN) Infinity “Infinity” true new Number(Infinity) -Infinity “-Infinity” true new Number(-infinity) 123 “123” true new Number(123) { } true [ ] 0 true [9] “9” 9 true [“a”] NaN true [1, 2] NaN true function() { } NaN true","categories":[{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/categories/javascript/"}],"tags":[{"name":"ecmascript","slug":"ecmascript","permalink":"http://noritersand.github.io/tags/ecmascript/"},{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/tags/javascript/"},{"name":"type","slug":"type","permalink":"http://noritersand.github.io/tags/type/"},{"name":"conversion","slug":"conversion","permalink":"http://noritersand.github.io/tags/conversion/"}]},{"title":"JavaScript: 래퍼 객체 wrapper objects","slug":"JavaScript-래퍼-객체-wrapper-objects","date":"2018-03-20T07:08:35.000Z","updated":"2018-07-11T00:15:13.196Z","comments":true,"path":"javascript/JavaScript-래퍼-객체-wrapper-objects/","link":"","permalink":"http://noritersand.github.io/javascript/JavaScript-래퍼-객체-wrapper-objects/","excerpt":"","text":"참고한 글 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object http://www.insightbook.co.kr/book/programming-insight/자바스크립트-완벽-가이드 래퍼 객체란?이름처럼 래퍼(wrapper)는 원시(primitive) 타입의 값을 감싸는 형태의 객체다. number, string, boolean, symbol 데이터 타입에 각각 대응하는 Number, String, Boolean, Symbol이 제공된다. 래퍼 객체와 원시 타입간의 변환은 자바스크립트가 알아서 해주기 때문에 우리는 이를 신경쓰지 않아도 되며 명시적인 처리가 필요한 경우도 거의 없다. 다만 래퍼 객체를 아예 모르는 상태에선 종종 보이는 ‘이상한’ 현상에 당황할 수도… 아래를 보자:var s = \"abc\";typeof s; // \"string\"s.substring(1, 2); // 'b' s는 분명 문자열 원시 타입이다. 그런데 어떻게 메서드를 갖고 있을까?public class LogicTest &#123; public static void main(String... args) &#123; String s = \"abc\"; // new String(\"abc\"); s.substring(1, 2); &#125;&#125; 위는 자바에서 문자열을 다루는 코드다. 자바의 원시 타입에는 문자열이 존재하지 않는다. 자바의 문자열은 원칙적으로 new 키워드를 사용해야 하는 객체 타입이다. 다만 우리는 이 과정을 컴파일러에게 맡기고 new 키워드를 생략할 수 있을 뿐이다. 다시 말해 자바의 문자열은 생성될 때부터 객체 타입이며 메서드를 소유할 수 있다. 반면, 자바스크립트의 문자열은 원시 타입으로 존재한다. 우리가 문자열의 프로퍼티에 접근하려고 할 때(가령 length 같은) 자바스크립트는 new String을 호출한 것처럼 문자열 값을 객체로 변환한다. 이 객체를 래퍼 객체라고 한다. 래퍼 객체는 프로퍼티를 참조할 때 생성되며 프로퍼티 참조가 끝나면 사라진다. 아래 현상은 위와 같은 특성으로 발생한다:var s = \"test-test\";s.len = 4; // new String(s).len = 4console.debug(s.len); // 'undefined' 두 번째 라인에서 s.len의 값으로 4를 할당했다. 하지만 다시 꺼내었을 때 출력되는건 ‘undefined’다. 두 번째 라인의 s는 new String(s)로 바뀌었고 3라인은 2라인과는 또 다른 객체를 참조하고 있기 때문이다. 애초에 할당된 적이 없는 s.len을 참조하고 있는 셈이 된다.var n = 123;typeof n; // \"number\"n.toExponential();n.prop = 1;console.debug(n.prop); // 'undefined'var b = true;typeof b; // \"boolean\"b.toString()b.name = 'abc';console.debug(b.name); // 'undefined' 숫자와 불리언 타입도 문자열과 같은 방식으로 작동한다. 변수의 프로퍼티에 접근할 때 래퍼 객체가 ‘임시로’ 생성된다. 프로퍼티의 값을 할당하는 것은 ‘임시로’ 생성된 래퍼 객체에서 수행되며 지속되지 않는다. 때문에 원시 타입의 프로퍼티(실제로는 래퍼 객체의 프로퍼티)가 마치 읽기 전용 값처럼 존재하는 것이다.var n = 1;var N = new Number(n);console.debug(n == N); // trueconsole.debug(n === N); // false 원시 타입과 래퍼 객체는 거의 동등한 값처럼 다뤄진다. 동등 연산자==로는 이 둘을 구분할 수 없지만 엄격한 동등 연산자===로 구분할 수 있다. 래퍼 객체의 명시적 생성 금지var sym = new Symbol(); // TypeError 원시 타입 변수에 대해 명시적인 래퍼 객체를 만드는 것은 ES2015(ES6)부터 지원되지 않는다. 실제로 Symbol 타입은 new 연산자를 사용할 경우 TypeError가 발생한다. ‘레거시(legacy) 요인’으로 아직 가능하다는 말로 봐선 추후 버전에선 Boolean, String, Number 타입도 마찬가지로 금지될 가능성이 높아보인다. 출처var prmt = 1234;typeof prmt; // \"number\", 원시 타입var obj = Object(1234);typeof obj; // \"object\", 래퍼 객체 그래도 써야겠다면 Object() 함수를 이용하는 방법이 있다. 하지만 쓸일이 없을껄?","categories":[{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/categories/javascript/"}],"tags":[{"name":"ecmascript","slug":"ecmascript","permalink":"http://noritersand.github.io/tags/ecmascript/"},{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/tags/javascript/"},{"name":"wrapper","slug":"wrapper","permalink":"http://noritersand.github.io/tags/wrapper/"}]},{"title":"JavaScript: 함수 Function","slug":"JavaScript-함수-Function","date":"2018-03-20T06:59:09.000Z","updated":"2018-07-11T00:15:13.204Z","comments":true,"path":"javascript/JavaScript-함수-Function/","link":"","permalink":"http://noritersand.github.io/javascript/JavaScript-함수-Function/","excerpt":"","text":"참고한 글 http://www.w3schools.com/Js/js_function_definition.asp https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Function 함수란?함수란 독립적으로 분리된 로직으로, 미리 정의되어 있거나 사용자 정의에 의해 만들어진 실행가능한 단위를 일컫는 말이다. 자바스크립트에선 함수는 객체로 존재하며 동시에 1급 함수다. 이것은 함수 객체를 변수나 데이터 구조 안에 담거나 전달인자 혹은 반환값으로 사용할 수 있다는 의미다.function 함수이름( [ 매개변수1, 매개변수2..., 매개변수n ] ) &#123; 구문 &#125; 함수 선언문은 function 키워드와 함수 이름, 구문 블록의 조합이다. 함수 이름 뒤에는 매개변수를 정의하는데, 매개변수는 타입을 지정하지 않으며 개수 제한이 없다. 매개변수의 타입은 호출될 때 결정된다. 함수 선언문(함수 구문)과 함수 정의 표현식function meIzDaBest() &#123; // ...&#125; 함수 선언문은 새 함수 객체를 만들되 함수 이름을 변수로 생성하여 함수 객체를 할당한다. 때문에 함수의 이름이 반드시 필요하며 위 코드와 같은 단 한 가지의 형태만 존재한다.var a = function() &#123; // ...&#125;;(function() &#123; // ...&#125;)(); 함수 정의 표현식은 말 그대로 함수를 정의하는 표현식이다. ‘함수 리터럴’이라 하기도 한다. 함수 선언문과 다르게 이름이 필요하지 않아 익명 함수라 부르기도 한다. 위의 코드 중 첫 번째는 함수 정의 표현식으로 생성한 함수를 변수에 할당하는 형태다. 두 번째는 함수를 생성하고 스스로 호출하는 자기 호출 함수(self invoking function)다. 함수의 끌어올림(hoisting)함수 선언문은 코드 중간에 삽입되어 있어도 항상 최상위에서 실행된다. 이것은 함수의 끌어올림(hoisting)이라 부른다. 가령 다음의 경우:var waaagh = 0; // 변수 선언function waaagh() &#123; // 같은 이름으로 함수 선언 // ...&#125;waaagh(); // TypeError: waaagh is not a functionwaaagh; // 0 waaagh라는 식별자로 변수를 정의한 뒤 같은 이름의 식별자에 함수 객체를 할당한 것처럼 보인다. 하지만 실제로는 반대의 순서로 작동한다. 함수가 먼저 변수에 할당되고, 원시 타입값 0이 이를 덮어쓴다. 단, 함수 정의 표현식은 함수 끌어올림이 적용되지 않는다. (하지만 해당 함수 내부의 변수에 대한 끌어올림은 적용된다) 아래를 보면:fnDeclaration(); // hifnExpression(); // TypeError: fnExpression is not a functionfunction fnDeclaration() &#123; console.debug('hi');&#125;var fnExpression = function() &#123; console.debug('im not');&#125;; fnExpression의 호출문이 표현식보다 먼저 왔을때 타입에러가 발생한다. 왜 참조에러가 아니고 타입에러일까? 위 코드는 실제로 아래처럼 작동하기 때문이다.function fnDeclaration() &#123; console.debug('hi');&#125;var fnExpression;fnDeclaration(); // hifnExpression(); // TypeError: fnExpression is not a functionfnExpression = function() &#123; console.debug('im not');&#125;;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/categories/javascript/"}],"tags":[{"name":"ecmascript","slug":"ecmascript","permalink":"http://noritersand.github.io/tags/ecmascript/"},{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/tags/javascript/"},{"name":"function","slug":"function","permalink":"http://noritersand.github.io/tags/function/"}]},{"title":"JavaScript: 변수의 유효범위와 끌어올림hoisting","slug":"JavaScript-변수의-유효범위와-끌어올림hoisting","date":"2018-03-20T06:57:09.000Z","updated":"2018-07-11T00:15:13.197Z","comments":true,"path":"javascript/JavaScript-변수의-유효범위와-끌어올림hoisting/","link":"","permalink":"http://noritersand.github.io/javascript/JavaScript-변수의-유효범위와-끌어올림hoisting/","excerpt":"","text":"함수 단위의 유효범위C, JAVA같은 프로그래밍 언어는 블록 안에 있는 코드는 자신만의 유효범위를 가지며, 변수는 해당 변수가 선언되지 않은 블록 밖에서는 보이지 않는다. 이를 블록 단위의 유효범위라 부르는데 자바스크립트는 이와 달리 함수 단위의 유효범위를 갖는다. 함수 단위 유효범위란 함수 안에서 선언된 모든 변수가 함수 내 전체에서 유효하다는 의미다.function fn() &#123; &#123; var scope = 'local'; // 블록 내에서 선언. &#125; return scope; // 같은 함수 내에 있으므로 접근 가능&#125;fn(); // local 다른 언어에 익숙하다면 위 코드가 말이 안되는 것처럼 보일 수 있다. 하지만 ‘함수 단위의 유효범위’의 의미를 생각해보면 충분히 말이 된다. 자바스크립트는 이런식으로 scope를 블록이 아닌 함수로 구분한다. 끌어올림, hoisting자바스크립트 코드는 함수 안에 있는 모든 변수를 함수 맨 꼭대기로 ‘끌어올린’것처럼 작동한다. 다만 이 ‘끌어올린’다는 표현은 변수의 선언에만 해당하는 것으로 값을 할당하는 변수의 초기화는 제외한다. 가령 다음을 보면:var scope = 'global';function a() &#123; console.log(scope); // undefined var scope = 'local'; console.log(scope); // local&#125;a(); 3행에서 지역 변수 scope는 아직 선언되지 않았으므로 전역 변수 scope의 값인 &quot;global&quot;을 출력해야 한다고 오해할 수 있다. 하지만 &quot;undefined&quot;가 출력되는데 위 코드는 실제로 아래와 같이 작동하기 때문이다:var scope = 'global';function a() &#123; var scope; console.log(scope); // undefined scope = 'local'; console.log(scope); // local&#125;a(); 변수는 그 변수가 정의된 함수의 시작부분에서 생성되지만 var 구문이 실행되기 전까지는 초기화되지 않는다.. 즉, 변수는 존재하지만 초기화 되기 전에 참조했으므로 undefined가 반환되는 것이다.console.log(grrr); // can't access lexical declaration `grrr' before initializationlet grrr = 123; 예외로 let 키워드로 선언된 변수의 경우 끌어올려지긴 하지만 초기화 전에 호출했을 때 참조 에러가 발생한다.끌어올림은 변수뿐만 아니라 함수에도 적용된다.","categories":[{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/categories/javascript/"}],"tags":[{"name":"ecmascript","slug":"ecmascript","permalink":"http://noritersand.github.io/tags/ecmascript/"},{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/tags/javascript/"},{"name":"hoisting","slug":"hoisting","permalink":"http://noritersand.github.io/tags/hoisting/"}]},{"title":"JavaScript: 전역 함수 global functions","slug":"JavaScript-전역-함수-global-functions","date":"2018-03-20T06:40:02.000Z","updated":"2018-07-11T00:15:13.200Z","comments":true,"path":"javascript/JavaScript-전역-함수-global-functions/","link":"","permalink":"http://noritersand.github.io/javascript/JavaScript-전역-함수-global-functions/","excerpt":"","text":"참고한 글 https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference http://www.w3schools.com/jsref/jsref_obj_global.asp eval(), uneval()eval( jsString )uneval( object ) jsString: 코드로 읽어들일 문자열 object: 문자열로 변환할 객체 문자열 리터럴을 자바스크립트 코드로 읽고 실행하거나 반대로 코드나 객체를 문자열로 변환한다. 예를 몇가지 들면: eval(‘432 * 10’) 의 경우엔 432 x 10의 결과인 4320이 리턴된다. eval(‘alert()’) 의 경우 경고창이 띄워진다. 다음 코드는 form.search_word의 value를 리턴한다: eval(&quot;document.forms[0].search_word.value&quot;); 다음 코드는 name프로퍼티를 갖는 Javascript Object를 의미한다: eval(&#39;{name=&quot;value&quot;}&#39;) 참고로 eval()을 대신하여 Function 생성자를 이용하기도 한다.( new Function( 'alert(\"hi\");' ) )(); uneval()은 비표준 함수로 chrome에서 지원되지 않는다. encodeURI(), decodeURI()encodeURI( jsString )decodeURI( jsString ) jsString: 변환할 문자열 문자열을 HTTP 전송에 적합한 코드로 암호화하거나 복호화한다.encodeURI('가'); // \"%EA%B0%80\"decodeURI('%EA%B0%80'); // \"가\" encodeURIComponent(), decodeURIComponent()encodeURIComponent( jsString )decodeURIComponent( jsString ) jsString: 변환할 문자열 encodeURI()는 jsString을 쿼리스트링의 전체라고 보며 “?”, “=”, “&amp;”를 변환하지 않는다.반면 encodeURIComponent()는 jsString을 쿼리스트링의 일부분이라 보며 예외 없이 모든 문자를 변환한다.encodeURI('?=&amp;'); // \"?=&amp;\"encodeURIComponent('?=&amp;'); // \"%3F%3D%26\" isFinite(), isNaN()isFinite( testValue ) testValue: 테스트할 수치 수치가 무효 수치인가, 유효한 수치인가를 판명한다. 유효수치이면 true 값을 반환하고(return), 무효수치이면 false 값을 반환한다. isNaN() 과는 반대 결과를 반환한다.isNaN( testValue ) testValue: 테스트할 수치 isNaN()은 isFinite()의 반대격으로 무효수치이면 true 값을 반환하고(return), 유효수치이면 false 값을 반환한다. (문자열 앞의 공백은 검사할 수 없다.)isFinite(2002); // trueisFinite('123.4567'); // trueisFinite('a'); // falseisNaN('123.4567'); // falseisNaN(1); // falseisNaN(\"Hello\"); // true parseFloat()parseFloat( object ) object: 변환할 수치 값을 부동 소수점 실수로 변환 한다.parseFloat(\"10.33\"); // 10.33parseFloat(\"5.4321e6\") // 5432100 parseInt()parseInt( object [, radix ] ) object: 변환할 수치. radix: 기수 (진수 구분) 값을 정수로 변환한다. 숫자로 변환 불가능한 값을 입력받으면 NaN을 리턴한다.parseInt(100); // 100parseInt('100'); // 100parseInt(new String(1100)); // 1100parseInt('10.00'); // 10parseInt('10.98'); // 10parseInt('40 years'); // 40parseInt('010'); // 10parseInt('0x10'); // 16 radix가 있고 없고의 결과가 다르다. 예를 들어 radix가 16일 때 object는 16진수로 간주된다.parseInt(100, 16); // 256 이 경우 숫자 16진수 100을 10진수로 변환한 결과인 256을 리턴한다.","categories":[{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/categories/javascript/"}],"tags":[{"name":"ecmascript","slug":"ecmascript","permalink":"http://noritersand.github.io/tags/ecmascript/"},{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/tags/javascript/"},{"name":"function","slug":"function","permalink":"http://noritersand.github.io/tags/function/"}]},{"title":"JavaScript: 제어문 control statement","slug":"JavaScript-제어문-control-statement","date":"2018-03-20T06:10:49.000Z","updated":"2018-07-11T00:15:13.200Z","comments":true,"path":"javascript/JavaScript-제어문-control-statement/","link":"","permalink":"http://noritersand.github.io/javascript/JavaScript-제어문-control-statement/","excerpt":"","text":"참고한 글 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Control_flow_and_error_handling https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Loops_and_iteration 조건문if-else표현식이 true일 때(혹은 true로 변환되는 값일 때) 구문을 실행한다.if (표현식) &#123; 구문 &#125; var a = 1;if (a) &#123; if (a == 1) &#123; console.log(a); &#125;&#125;else if (a === null) &#123; console.log('a is null')&#125;else &#123; console.log('a is undefined');&#125; switch표현식의 값과 case 레이블의 값이 일치하면 case 다음에 오는 구문을 실행한다. 만약 일치하는 case 레이블이 없으면 default 레이블의 구문을 실행한다.switch (표현식) &#123; 구문 &#125; var a = 1;switch (a) &#123; case 1: console.debug('first'); break; case 2: console.debug('second'); break; default: console.debug('eliminated'); break;&#125; break나 return으로 끝나지 않은 case 레이블의 코드 블록은 바로 다음에 이어지는 case 레이블의 구문을 실행시킨다:var a = 3;switch (a) &#123; case 1: console.log('일'); case 2: console.log('이'); case 3: console.log('삼'); // 실행됨 case 4: console.log('사'); // case 3에서 break로 끝나지 않았으므로 실행됨 default: console.log('디폴트'); // case 4에서 break로 끝나지 않았으므로 실행됨&#125; 루프문while표현식을 평가해 true일 때 구문을 실행한다. 구문 실행이 끝나면 다시 한번 표현식을 평가하며 표현식이 false로 평가될 떄까지 이 과정을 반복한다.while (표현식) &#123; 구문 &#125; var i = 0;while (++i &lt; 10) &#123; console.log(i); // 1부터 9까지 출력&#125; 표현식이 true면 무한 루프가 된다:while (true) &#123; // 무한 루프&#125; do-while우선 do의 구문을 선실행한 후 표현식을 평가한다. 구문을 선실행하는 것만 빼면 while과 같다.do &#123; 구문 &#125; while (표현식); var i = 0;do &#123; console.log(i); // 0부터 9까지 출력&#125; while (++i &lt; 10); for루프가 시작되기 전 초기화를 한 번 실행한다. 그 후 표현식을 평가하여 true일 때 구문을 실행한다. 코드 블록의 끝을 만나면 증감식을 실행한 후 다시 표현식을 평가한다. 이 과정은 표현식이 false가 될 떄까지 반복된다.for (초기화; 테스트 표현식; 증감식) &#123; 구문 &#125; 일반적인 사용은 다음과 같다:for (var i = 0 ; i &lt; 10; i++) &#123; console.log(i); // 0부터 9까지 출력&#125; 만약 초기화가 필요없다면 생략할 수 있다. 증감식도 마찬가지:var i = 0;for (; i &lt; 10;) &#123; // 초기화와 증감식 생략 console.log(i); // 0부터 9까지 출력 i++;&#125; 테스트 표현식까지 생략할 수 있는데, 이렇게 되면 무한 루프다:for (;;) &#123; // 무한 루프&#125; 쉼표 연산자를 사용하면 여러 변수의 초기화나 증감을 for문에 적용할 수 있다:for (var i = 0, j = 10; i &lt; 10; i++, j--) &#123; console.log('i: ', i); // 0부터 9까지 출력 console.log('j: ', j); // 10부터 1까지 출력&#125; 다음 코드를 보면 for문에서 초기화되는 변수도 끌어올림(hoisting)이 적용되는것을 확인할 수 있다.var i = 'global';(function() &#123; console.log(i); // 끌어올림이 적용되어 'global'이 아니라 undefined 출력됨 for (var i = 0 ; i &lt; 10; i++) &#123; console.log(i); // 0부터 9까지 출력 &#125;&#125;)(); for-in객체가 소유한 프로퍼티의 길이만큼 구문을 반복하되 각 루프마다 객체가 갖고 있는 프로퍼티의 이름을 변수에 할당한다. 객체의 모든 프로퍼티만큼 반복하는 것은 아니고 ‘열거 할 수 있는 프로퍼티(enumerable이 true인 프로퍼티. 예를 들어 모든 객체의 프로퍼티지만 Object로부터 상속받은 프로퍼티는 열거 할 수 없다. 다만 구현체마다 열거 가능한 프로퍼티가 다를 수 있으므로 주의.)’의 길이만큼만 반복한다.for (변수 in 객체) &#123; 구문 &#125; for (var prop in window) &#123; console.log(window[prop]);&#125; 자바스크립트는 루프를 실행하기 전에 먼저 객체를 평가한다. 만약 객체 타입이 아닌 원시 타입이라면 래퍼 객체로 변환될 것이다:var str = 'abc';for (var prop in str) &#123; console.log(str[prop]); // a b c 출력&#125; 배열은 객체로 취급되며 배열을 구성하는 각 요소가 배열의 프로퍼티다. 그리고 배열의 인덱스가 프로퍼티 이름이 된다:var arr = ['a', 'b', 'c'];for (var prop in arr) &#123; console.log(prop); // 0 1 2 출력&#125; for-offor-of는 for-in과 비슷하지만 프로퍼티의 이름이 아니라 프로퍼티의 값을 변수에 할당한다. 단, iterable object만 for-of로 반복할 수 있는데, iterable object에 해당되는 타입은 Array, String, TypedArray, Map 그리고 arguments object가 있다.for-of는 ES2015에 신규 추가되었고, IE에서는 사용할 수 없다.var arr = ['a', 'b', 'c', 'd'];for (var ele of arr) &#123; console.debug(ele); // 'a', 'b', 'c', 'd' 각각 출력&#125;var obj = &#123; a: 1, b: 2&#125;for (var ele of obj) &#123;&#125; // TypeError: obj is not iterable 점프문레이블특정 구문에 식별자 이름과 콜론으로 레이블을 붙인다. 레이블이 있는 구문은 continue와 break 키워드와 조합하여 점프문으로 사용된다. 보통은 중첩된 루프나 switch문에서 현재 구문이 가장 안쪽에 있지 않을 때 사용한다.식별자: 구문 var i, j;loop1:for (i = 0; i &lt; 3; i++) &#123; //The first for statement is labeled \"loop1\" loop2: for (j = 0; j &lt; 3; j++) &#123; //The second for statement is labeled \"loop2\" if (i === 1 &amp;&amp; j === 1) &#123; break loop1; &#125; console.log(\"i = \" + i + \", j = \" + j); &#125;&#125; breakbreak문을 감싸고 있는 가장 가까운 반복문이나 switch문을 탈출한다. 레이블이 명시되면 해당 레이블(과 연결된 구문)을 탈출한다.break [label]; var i = 0;while (true) &#123; i++; if (i &gt; 10) &#123; break; &#125;&#125; continue반복문 내에서 사용하며 break와 달리 반복문을 탈출하지 않고 다음 반복을 진행한다. ‘이번 반복은 생략’과 같은 의미다. for문을 예로 들면 continue를 만났을 때 증감식을 실행하는 부분부터 다시 시작한다. continue는 반드시 루프문 내에서 사용해야 한다. 그렇지 않으면 SyntaxError가 발생할 것이다. 레이블이 명시되면 해당 레이블부터 다음 반복을 진행한다.continue [label]; var arr = [1, 2, 3];for (var idx in arr) &#123; if (arr[idx] == 2) &#123; continue; &#125; console.debug(arr[idx]); // 2는 건너뛰므로 1 3 출력&#125;return 함수 내에서만 사용할 수 있는 키워드다. 평가된 표현식의 결과를 함수의 값으로 반환한다. 표현식은 생략될 수 있으며 이 경우 반환되는 값은 undefined. 반환된 값은 함수호출 표현식의 평가 결과가 된다.return 표현식; function add(a, b) &#123; return a + b;&#125; throw명시적인 예외를 발생시킨다. 발생지점을 감싼 try-catch가 없다면 에러로 취급되며 에러 메시지를 사용자에게 보고한다.function add(a, b) &#123; if (isNaN(a) || isNaN(b)) &#123; throw new Error('숫자가 아니네'); &#125; return a + b;&#125;add('a', 'b'); // Error: 숫자가 아니네 try-catch-finallytry는 ‘예외가 발생할지도 모르는’ 코드 블록을 정의한다. 이어지는 catch의 구문은 try 블록에서 예외가 발생했을 때 실행된다. finally는 try 블록의 코드가 일부라도 실행되고 나면 예외 발생 여부와 관계없이 반드시 한 번은 실행되는 코드 블록이다. finally는 생략 가능하다.try &#123; 구문 &#125; catch (error) &#123; 구문 &#125; finally &#123; 구문 &#125; error: Error.prototype의 인스턴스. name(에러 타입), message(에러 메시지), lineNumber(예외 발생 지점의 라인 번호), fileName(파일명)을 프로퍼티로 갖는다. var obj = &#123;&#125;;try &#123; obj.a();&#125; catch (e) &#123; console.log(e.name + ': ' + e.message); // TypeError: obj.a is not a function&#125; finally &#123; console.log('어찌되던 실행');&#125; finally의 반드시 한 번은 실행되는 속성은 try 코드 블록에서 return, continue, break를 만났을 때도 유효하다.var i = 0;while(++i &lt; 4) &#123; try &#123; continue; &#125; catch (e) &#123; &#125; finally &#123; console.log(i); // 1 2 3 출력 &#125;&#125; 주의해야 할 점은 try의 점프문에 의해 제어가 finally로 넘어갔을 땐 finally 코드 블록의 점프문이 try보다 우선권을 가진다는 것이다. 다음을 보면 try에서 ‘abc’를 반환하고 finally에서 undefined를 반환하도록 되어 있는데:function fn() &#123; try &#123; return 'abc'; &#125; catch (e) &#123; // ... &#125; finally &#123; return; &#125;&#125;fn(); // undefined 실제 반환되는 값은 finally의 undefined다.","categories":[{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/categories/javascript/"}],"tags":[{"name":"ecmascript","slug":"ecmascript","permalink":"http://noritersand.github.io/tags/ecmascript/"},{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/tags/javascript/"},{"name":"control-statement","slug":"control-statement","permalink":"http://noritersand.github.io/tags/control-statement/"}]},{"title":"JavaScript: 연산자 operator","slug":"JavaScript-연산자-operator","date":"2018-03-20T05:57:36.000Z","updated":"2018-07-11T00:15:13.199Z","comments":true,"path":"javascript/JavaScript-연산자-operator/","link":"","permalink":"http://noritersand.github.io/javascript/JavaScript-연산자-operator/","excerpt":"","text":"참고한 글 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators http://www.insightbook.co.kr/book/programming-insight/자바스크립트-완벽-가이드 산술 연산+ - * / % ++ -- 덧셈 연산자는 피연산자 중 하나가 문자열일 때 나머지 피연산자도 문자열로 변환하려고 시도한다. 그래서 &#39;nan&#39; + 1의 결과는 ‘nan1’이 된다.증가/증감++ -- 연산자는 피연산자를 가능할 경우 숫자 타입으로 변경한다. 가령 x++에서 x가 문자열 &quot;1&quot;이면 x는 숫자 1로 바뀌며 이후 1씩 증가된다. x가 숫자로 바꿀 수 없는 문자열일 경우 NaN을 반환한다. 할당 연산= += -= *= /= %=&amp;= ^= |= &lt;&lt;= &gt;&gt;= &gt;&gt;&gt;= 비교 연산== === != !== &gt; &lt; &gt;= &lt;= ===는 일치연산자 혹은 엄격한 동등 연산자라고 한다. ==는 동등(equal)을 판단하며 ===는 일치(identical)하는지 판단한다. 둘은 같음을 정의하는 기준이 다르다. 가령 ===는 값이 같아도(형변환을 통해 같다고 판단되는 값. 가령 1과 ‘1’은 동등하다.) 타입이 다를 경우 둘이 서로 다른것으로 판단한다. 동등 연산==의 판단 기준: 두 값의 타입이 같은 경우, 두 값이 일치하면 둘은 동등하다. 두 값의 타입이 다른 경우에도 여전히 동등할 여지가 있으므로 타입 변환이 사용된다. 두 값 중 하나가 null이고 다른 하나가 undefined라면 두 값은 동등하다. 두 값 중 하나가 문자열이고 다른 하나가 숫자면 문자열을 숫자로 변환한다. 두 값 중 하나가 true이면 이를 1로 변환, false일 땐 0으로 변환 후 비교한다. 한 값이 객체고 다른 하나가 숫자 또는 문자열이면 객체를 원시 타입으로 변환 후 비교한다. 객체의 원시 타입 변환에는 해당 객체의 toString() 메서드나 valueOf() 메서드가 사용된다. 일치 연산===의 판단 기준: 두 값의 타입이 서로 다르면 두 값은 일치하지 않는다. 두 값이 모두 null이거나 undefined면, 두 값은 일치한다. 두 값이 모두 불리언 값 true이거나 false일 경우에 두 값은 일치한다. 적어도 하나의 값이 NaN이면 두 값은 일치하지 않는다. NaN 값은 자기 자신을 포함해 다른 어떠한 값과도 일치하지 않는다. 임의의 값 x가 NaN인지 검사하기 위해서는 x !== x와 같이 사용한다. 앞의 표현식이 참을 만족 할 때만 x의 값이 NaN이 된다. 두 값이 모두 숫자고 같은 값을 갖는다면, 두 값은 일치한다. 만약 하나의 값이 0이고 다른 하나의 값이 -0일지라도, 두 값은 일치한다. 두 값이 모두 문자열이고, 같은 위치에 정확히 같은 16비트 문자열 값을 갖고 있다면, 두 값은 일치한다. 만약 문자열의 길이나 내용이 다를 경우, 두 값은 일치하지 않는다. 두 문자열이 같은 의미를 갖고, 육안상 같은 문자열을 갖더라도 16비트 값의 순서가 다르게 인코딩되어 있을 수도 있다. 자바스크립트에서는 유니코드 문자열에 대해서 정규화 과정을 수행하지 않는다. 또한 ===나 == 연산자를 사용해 유니코드 문자열의 동등 비교를 할 수 없다. 이와 같은 문자열을 비교하려면 String.localeCompare()를 사용한다. 두 값이 모두 같은 객체나 배열 또는 함수를 참조하고 있으면, 두 값은 일치한다. 두 값이 서로 다른 객체를 참조할 경우에 설사 두 객체의 프로퍼티가 일치하더라도 두 값은 일치하지 않는다. 논리 연산&amp;&amp; || ! var a = 0, b = 1;a == 0 &amp;&amp; b == 1; // truetrue &amp;&amp; b == 0; // falsea != b || b != b; // truefalse || true; // truefalse || (true &amp;&amp; false); // false 논리 연산자 &amp;&amp;, || 는 피연산자가 관계 표현식 또는 boolean 타입이거나 괄호로 감싼 논리 표현식일 땐 일반적인 AND와 OR연산을 수행한다.만약 피연산자가 boolean이 아닐 때 해당 피연산자는 boolean 타입으로 변환된다. 이후 규칙에 따라 값을 반환하는데, 반환되는 값은 boolean이 아니라 boolean으로 변환되기 전인 원래의 값이 반환된다. 가령 다음을 보면:undefined &amp;&amp; 1; // undefined undefined가 false로 변환되고 연산식을 평가한 후 다시 원래의 값인 undefined가 반환된다.1 &amp;&amp; 2; // 23 &amp;&amp; 1; // 10 &amp;&amp; undefined; // 0undefined &amp;&amp; 0; // undefined123 &amp;&amp; null; // nullnull &amp;&amp; 123; // null &amp;&amp;는 다음 규칙을 따른다: 피연산자가 모두 true일 땐 우변 피연산자의 값을 반환 피연산자가 모두 false일 땐 좌변 피연산자의 값을 반환 둘 중 하나가 false일 땐 false로 평가되는 값을 반환 [] || &#123;&#125;; // Array [ ]\"123\" || window; // \"123\"null || undefined; // undefinedundefined || null; // null0 || 1; // 11 || 0; // 1 ||는 다음 규칙을 따른다: 피연산자가 모두 true일 땐 좌변 피연산자의 값을 반환 피연산자가 모두 false일 땐 우변 피연산자의 값을 반환 둘 중 하나가 false일 땐 true로 평가되는 값을 반환 다른 연산자도 마찬가지지만 논리 연산자 또한 피연산자를 비교하기 전에 각 피연산자를 평가(evaluate)하는 과정을 거친다. 표현식이나 호출식을 먼저 실행한 후 비교한다고 생각하면 된다. 그리고 상황에 따라 우변의 피연산자는 평가될 수도 있고 평가되지 않을 수도 있다는 것을 주의해야 한다. 다음 예를 보면:alert(1) || alert(2); OR 연산은 좌변이 false일 때 우변도 평가한다. (window.alert의 리턴값은 undefined) 따라서 경고창은 두 번 나타난다.alert(1) &amp;&amp; alert(2); AND 연산은 좌변이 false일 때 우변을 평가하지 않는다. 따라서 경고창은 한 번 나타난다.true || alert(2); OR 연산은 좌변이 true일 때 우변을 평가하지 않는다. 이 경우 경고창이 나타나지 않는다.true &amp;&amp; alert(2); AND 연산은 좌변이 true일 때 우변을 평가한다. 경고창이 나타난다. 다음은 논리 연산자로 삼항 연산을 흉내낸 것이다:var a = 1;var result = (a == 1) &amp;&amp; 'equal' || 'not equal';console.log(result); // \"equal\" OR 연산자의 좌변과 우변이 모두 true로 평가되는 값일 때만 제대로 작동하는 한계가 있지만… 비트 연산 ~: 비트단위 NOT &amp;: 비트단위 AND |: 비트단위 OR ^: 비트단위 XOR &lt;&lt;: 왼쪽으로 이동 &gt;&gt;: 부호 비트를 확장하면서 오른쪽으로 이동 &gt;&gt;&gt;: 부호 비트 확장 없이 오른쪽으로 이동 삼항 연산자조건 연산자 또는 선택 연산자. TRUE 혹은 FALSE에 해당하는 값을 반환한다.조건 ? TRUE : FALSE var a = 1;var result = (a == 1) ? \"일\" : \"일 아님\";console.log(result); // \"일\" instanceof객체의 프로토타입 체인에 생성자의 프로토타입이 존재하는지 테스트한다. 좌변의 피연산자로 객체를 받고 우변의 피연산자로 생성자를 받는다. 이 연산자로 객체가 특정 타입의 인스턴스인지 판단할 수 있다. 우변은 반드시 함수 이름이어야 하는데, 만약 함수가 아니면 TypeError가 발생할 것이다.object instanceof constructor function fn() &#123; // blah blah blah&#125;fn instanceof Function; // truealert instanceof Function; // true\"\" instanceof String; // false, 문자열 자체는 원시 타입이기 때문new String() instanceof String; // true, String 래퍼 객체는 String의 인스턴스[] instanceof Array; // true, [].__proto__ === Array.prototype[] instanceof Object; // true, 모든 객체는 Object의 인스턴스 typeof연산자 다음에오는 변수, 함수, 객체 또는 표현식의 타입을 반환한다.typeof expression typeof \"John\" // \"string\"typeof 3.14 // \"number\"typeof NaN // \"number\"typeof false // \"boolean\"typeof [ 1, 2, 3, 4 ] // \"object\"typeof &#123; name: 'John', age: 34 &#125; // \"object\"typeof new Date() // \"object\"typeof function() &#123;&#125; // \"function\"typeof myCar // \"undefined\" (if myCar is not declared)typeof null // \"object\" in객체나 배열에 특정 프로퍼티가 존재하는지 확인한다.expression in Object // Arraysvar cars = [ \"Saab\", \"Volvo\", \"BMW\" ];\"Saab\" in cars // false, 'Saab'은 프로퍼티의 이름이 아니라 값이므로 false0 in cars // true1 in cars // true4 in cars // false, cars의 길이는 3이므로 배열의 4번째 인덱스는 없다.\"length\" in cars // true, Array 래퍼 객체에 length란 프로퍼티가 존재함.// Objectsvar person = &#123; firstName: \"John\", lastName: \"Doe\", age: 50 &#125;;\"firstName\" in person // true\"age\" in person // true// Predefined objects\"PI\" in Math // true\"NaN\" in Number // true\"length\" in String // true 또한 in은 for-in 반복문에서 사용된다.for (variable in object) &#123; ... &#125; object: 반복할 객체. 객체의 프로퍼티 만큼 반복된다. variable: 매번 반복될 때마다 프로퍼티의 key를 할당한다. 만약 반복되는 객체가 배열일 경우 인덱스를 할당할 것이다. var foo = &#123; a: 1, b: 2&#125;;var propNames = [];for (var ele in foo) &#123; propNames.push(ele);&#125;console.log(propNames); // [ \"a\", \"b\" ]var foo2 = [ 'aaa', 'bbb', 'ccc' ];var idxs = [];for (var ele in foo2) &#123; idxs.push(ele);&#125;console.log(idxs); // [ \"0\", \"1\", \"2\" ] delete프로퍼티를 삭제한다. 삭제에 성공했을 때 true를, 실패했을 때 false를 반환한다.delete Object.property var fn = &#123; word: \"hi\" &#125;;console.log(fn.word); // \"hi\"delete fn.word; // trueconsole.log(fn.word); // undefined var문으로 정의된 변수(전역 객체의 프로퍼티라 하더라도), 함수 선언문(또는 함수 구문)으로 정의된 함수, 함수 매개변수로 선언한 함수는 삭제할 수 없다.var a = 1;delete a; // falsefunction fn() &#123; &#125;delete fn; // falsefunction callee(callback) &#123; console.debug(delete callback); // false&#125;callee(function() &#123;&#125;); voidvoid expression void 연산자는 피연산자를 실행하고 undefined를 반환한다. 피연산자를 실행해야 하지만 결과를 노출하고 싶지 않을때 사용한다.&lt;a href=\"javascript:void window.open()\"&gt;open&lt;/a&gt; void는 같은 이름의 함수가 존재하는데:void(0); // undefinedvoid(); // SyntaxError: expected expression, got ')' 연산자와 마찬가지로 항상 undefined를 반환하는 함수다. 전달인자는 어느 값이어도 상관 없지만 할당하지 않으면 에러가 발생한다. 이동할 주소가 없는 앵커 태그가 필요할 때 종종 사용된다.&lt;a href=\"javascript:void(0)\"&gt;test&lt;/a&gt;","categories":[{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/categories/javascript/"}],"tags":[{"name":"ecmascript","slug":"ecmascript","permalink":"http://noritersand.github.io/tags/ecmascript/"},{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/tags/javascript/"},{"name":"operator","slug":"operator","permalink":"http://noritersand.github.io/tags/operator/"}]},{"title":"JavaScript: 기본","slug":"JavaScript-기본","date":"2018-03-20T05:40:10.000Z","updated":"2018-07-11T00:15:13.195Z","comments":true,"path":"javascript/JavaScript-기본/","link":"","permalink":"http://noritersand.github.io/javascript/JavaScript-기본/","excerpt":"","text":"참고한 글 https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Grammar_and_Types https://developer.mozilla.org/en-US/docs/Web/JavaScript/Data_structures http://www.insightbook.co.kr/book/programming-insight/자바스크립트-완벽-가이드 주석 처리SingleLine Comment// 주석처리될 문자열 MultiLine Comment/* 주석 처리될 문자열*/ 명령줄 구분2개 이상의 Script 명령을 사용할 경우 세미콜론:으로 구분한다.표현식1; 표현식2;표현식3; var a = 1; var b = 2;var c = a + b; 단, 아래처럼 예외적으로 줄바꿈을 세미콜론으로 해석하는 경우가 있다.현재 구문의 다음에 오는 공백이 아닌 문자를 해석할 수 없는 경우:var aa=3console.log(a)// var a; a=3; console.log(a); return, break, continue 문 후에 줄바꿈 할 경우:returntrue;// return; true; ++, -- 후에 줄바꿈 할 경우:x++y// x; ++y; HTML 문서에 자바스크립트 포함시키기Inline JavaScriptHTML Tag 속성에 지정하여 사용. &lt;body&gt; 내에서 사용한다.&lt;a href=\"javascript:location.href='http://daum.net'\"&gt;다음&lt;/a&gt; Embedded JavaScript스크립트 블록&lt;script&gt;&lt;/script&gt; 안에 일괄 지정. &lt;head&gt;와 &lt;body&gt; 어느곳에든 사용할 수 있다.&lt;html&gt; &lt;head&gt; &lt;script&gt; document.write(\"경고창 전에 출력될 문자\"); alert(\"redalert?\"); document.write(\"경고창 후 출력될 문자\"); &lt;/script&gt; &lt;/head&gt; &lt;body&gt;&lt;/body&gt;&lt;/html&gt; Linked JavaScript외부 파일을 링크하여 여러개의 파일에 일괄 지정. &lt;body&gt;에 사용해도 가능하지만 보통은 &lt;head&gt;에 위치한다.&lt;html&gt; &lt;head&gt; &lt;script src='test.js'&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;/body&gt;&lt;/html&gt; 특수 문자의 출력특수문자는 이스케이프 시퀀스로 표현한다: \\u: 유니코드 이스케이프 시퀀스 \\x: Latin-1 이스케이프 시퀀스 \\n: 줄바꿈 (\\u000A) \\b: 백스페이스 (\\u0008) \\t: 수평 탭 (\\u000B) \\v: 수직 탭 (\\u000B) \\r: CR, 캐리지리턴 (\\u000D) \\0: null (\\u0000) \\f: 폼 피드 (\\u000C) \\&quot;: 쌍따옴표 (\\u0022) \\&#39;: 홑따옴표 (\\u0027) \\r: 줄바꿈 문자 (\\u000A) \\\\: 역슬래시 (\\u005C) 따옴표 처리console.log(&quot;&apos;테스트&apos;&quot;); // &apos;테스트&apos;console.log(&quot;\\&quot;테스트\\&quot;&quot;); // &quot;테스트&quot;console.log(&apos;&quot;테스트&quot;&apos;); // &quot;테스트&quot; 자바스크립트의 변수식별자 명명 규칙기본규칙: 영문자, 숫자, _, $ 기호등을 조합하여 지정한다. 변수의 첫글자는 반드시 영문자, $, _ 기호중의 하나를 이용하여야 한다. 예약어는 사용할수 없다. 대소문자를 구분한다. 다음 키워드는 식별자로 사용할 수 없다: break delete function return typeof case do if switch var catch else in this void continue false instanceof throw while debugger finally new true with default for null try 다음은 전역 변수 혹은 전역 함수이므로 식별자로 사용하면 안된다: arguments encodeURI Infinity Number RegExp Array encodeURIComponent isFinite Object String Boolean Error isNaN parseFloat SyntaxError Date eval JSON parseInt TypeError decodeURI EvalError Math RangeError undefined decodeURIComponent Function NaN ReferenceError URIError 다음 키워드는 ECMAScript 5 에서 사용할 수 없다: class const enum export extends import super strict mode(엄격 모드)에서는 다음 예약어를 사용할 수 없다: implements let private public yield interface package protected static arguments eval 다음 키워드는 ECMAScript 3 에서 사용할 수 없다: abstract double goto native static boolean enum implements package super byte export import private synchronized char extends int protected throws class final interface public transient const float long short volatile 변수의 데이터 타입 number: 숫자를 표현하거나 산술 연산을 하는데 사용되는 데이터 타입이다. 기본적으로 +, -, *, / 등의 산술연산이 가능하며 Math 라는 내장객체를 이용하여 수학함수를 이용한 결과를 얻을 수도 있다. 자바스크립트의 Number는 “64비트 형식 IEEE 754 값” 으로 정의 된다. 이 때문에 간혹 의도하지 않은 결과가 나오기도 한다. string: 문자열을 표현하는데 사용되는 데이터 타입이다. 자바스크립트의 문자열은 16비트 유니코드 문자들의 연결구조 이기도 하다. 즉 문자열이라 함은 문자 하나하나가 연결되어 하나의 표현을 이루는 데이터를 말하는 것이다. boolean: true, false값을 가지는 논리 데이터 타입. Boolean() 함수를 이용하여 검증을 수행할수 있다. function: 함수 타입. 자바스크립트에서 함수는 Function 객체를 의미한다. null, undefined: null은 아무 값도 갖지 않거나(no value) 객체가 아닌 것을 의미하는 특수한 객체 값이다. 반면 undefined는 값 자체가 없음을 나타낸다. 초기화되어 있지 않거나 존재하지 않는 객체 프로퍼티 혹은 배열의 원소값에 접근하려고 할 때 얻는 값이다. null과 undifined는 둘 다 값이 없음을 가리키고 false로 판정된다. 동등 비교==에서 둘은 같다고 간주하지만 엄격한 동등 비교===에선 다른것으로 나온다. object: 일반적인 값이 아닌 다른 객체의 참조값을 갖는 데이터 타입. Array, Date, RegExp, Error 등이 Object type이다. 변수 선언과 초기화var 변수명; 변수명 = 3;혹은var 변수명 = 3; var a;a = 1;var b = 2;var c = a + b; 변수의 유효범위자바스크립트의 변수는 블록 단위가 아닌 함수 단위로 유효범위를 갖는다.var a = 0;&#123; var b = 1;&#125;console.debug(b); // 1 위 코드에서 b는 a와 블록으로 나뉘어 있지만 같은 함수에 있으므로 동일한 유효범위를 갖는다.var a = \"에이\";function test() &#123; b = \"비\"; var c = \"씨\";&#125;function test2() &#123; document.write(\"a : \" + a); // 에이 document.write(\"b : \" + b); // 비 document.write(\"c : \" + c); // undefined&#125;test();test2(); 위 코드에서 c는 함수 내에서 선언된 변수, 즉 지역 변수이기 때문에 아무것도 출력되지 않는다. 변수 b처럼 함수 내에서 선언되었어도 var 키워드를 생략하면 해당 변수는 마치 미리 선언된 전역 변수처럼 작동한다. (단, strict mode에선 허용되지 않음) Literal, 리터럴리터럴이란 정의되어 있는 그대로 해석되어야 하는 값을 말한다. 숫자 혹은 문자로 표현된다. http://www.terms.co.kr/literal.htm 정수 리터럴‘0x’, ‘0X’ 로 시작하면 16진수로 인식한다.0xff // 십진수 255 (15*16 + 15) ‘0’ 뒤에 0~7 사이의 숫자 시퀀스가 오면 8진수로 인식한다.0377 // 십진수 255 (3*64 + 7*8 + 7) 단, 8진수 표기는 ES 표준이 아니기 때문에 사용하지 않는것을 권장하고 있다. (ES5의 Strict mode에서는 명시적으로 0으로 시작하는 정수 표기법을 금지함.) 부동소수점 리터럴부동소수점 리터럴은 전통적인 지수표기법과 같다.[digits][.digits][(E|e)[(+|-)]digits] 6.02e23 // 6.02 * 10231.4738E-32 // 1.4738 * 10.32 문자열 리터럴문자열은 연속적으로 나열된 16비트 값으로 표현한다. 각 문자는 수정할 수 없는 유니코드(UTF-16) 문자다.\"Hello World!\" 자바스크립트의 문자열 리터럴은 여타 언어와 마찬가지로 따옴표로 표현한다.Java와 비교해 다른점은 큰따옴표, 작은따옴표 어느것을 사용해도 무방하다는 것이다:\" ' testing' \" // ' testing ', 자바와 같다.' \" testing \" ' // \" testing \", 자바스크립트만 가능한 표현 이 외에 ES3에선 문자열 리터럴을 반드시 한 줄로 작성해야 하지만, ES5에선 줄 끝에 역슬래시\\를 놓는 방식으로 여러 줄의 문자열 리터럴을 마치 한 줄인것 처럼 작성할 수 있다. 이때 문자 사이의 공백은 탭으로 처리된다.\"one\\long\\line\" // one long line ES5에서 문자열은 읽기 전용 배열처럼 취급할 수 있다. (문자열, 숫자, 불리언은 기본적으로 읽기 전용 값이다.)s = \"hello, world\";s[0]; // \"h\"s[s.length-1]; // \"d\" 함수 리터럴var add = function(a, b) &#123; return a + b;&#125;; 함수 리터럴은 다른 말로 ‘함수 정의 표현식’이라고 한다. 객체와 배열 리터럴엄밀히 따져 배열 또한 객체지만 초기화 리터럴이 다르므로 둘을 구분 짓는다. 객체 리터럴var ob = &#123;&#125;; // new Object()와 같음ob.a = 1;ob; // Object &#123; a: 1 &#125;var obj = &#123; b: 2, c: &#123; d: 3 &#125; &#125;;obj.b; // 2obj['b']; // 2, 프로퍼티에 접근하는 표현식으로 obj.b와 같다.obj.c.d; // 3 배열 리터럴var arr = []; // new Array()와 같음arr[0] = 'abc';arr; // Array [ \"abc\" ]var arry = [ '1', '2', [ '3-1', '3-2' ] ];arry[1]; // \"2\"arry[2][1]; // \"3-1\" 복합 객체var complex = &#123; numeric: 123, alphabet: 'abc...', hangul: ['가', '나', '다']&#125;;complex.hangul[0]; // \"가\"","categories":[{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/categories/javascript/"}],"tags":[{"name":"ecmascript","slug":"ecmascript","permalink":"http://noritersand.github.io/tags/ecmascript/"},{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/tags/javascript/"},{"name":"basic","slug":"basic","permalink":"http://noritersand.github.io/tags/basic/"}]},{"title":"윈도우10: 파워쉘 명령어 powershell commands","slug":"윈도우10-파워쉘-명령어-windows10-powershell-commands","date":"2018-03-19T09:27:24.000Z","updated":"2018-07-11T00:15:13.215Z","comments":true,"path":"os/windows/윈도우10-파워쉘-명령어-windows10-powershell-commands/","link":"","permalink":"http://noritersand.github.io/os/windows/윈도우10-파워쉘-명령어-windows10-powershell-commands/","excerpt":"","text":"Start-Process기본 별칭: sapsStart-Process powershell –verb runAs # 관리자 권한으로 파워쉘 실행Start-Process explorer . # 현재 경로로 탐색기 실행(Start-Process는 생략 가능) Get-Content기본 별칭: typeGet-Content -Path nexus-2.14.5-02\\logs\\wrapper.log -Wait # 'tail -f'와 같음 Write-Output기본 별칭: echoWrite-Output $null &gt;&gt; dummy-for-commit.txt # 'touch'와 같음 Get-ChildItem기본 별칭: ls 환경 변수환경 변수 조회Get-ChildItem Env: # 모든 환경 변수 보기, ls env:와 같음Write-Output $env:path # 환경 변수 중 'path' 출력, echo $env:path와 같음. 사실 그냥 $env:path만 쳐도 된다 로컬 환경 변수 추가/삭제$env:test = 1234 # 환경 변수 'test' 추가[Environment]::SetEnvironmentVariable(\"test2\", \"1234\", \"Process\") # 로컬 환경 변수 추가 두 번째 방법Remove-Item Env:\\test # 환경 변수 'test' 삭제 글로벌 환경 변수 추가/삭제[Environment]::SetEnvironmentVariable(\"test\", \"1234\", \"User\") # 로그인한 사용자의 환경 변수로 'test' 추가[Environment]::SetEnvironmentVariable(\"test2\", \"1234\", \"Machine\") # 시스템 환경 변수로 'test2' 추가, 이 명령은 관리자 권한 필요하다[Environment]::SetEnvironmentVariable(\"test\", $null, \"User\") # 사용자 환경 변수 'test' 삭제[Environment]::SetEnvironmentVariable(\"test2\", $null, \"Machine\") # 시스템 환경 변수 'test2' 삭제","categories":[{"name":"os","slug":"os","permalink":"http://noritersand.github.io/categories/os/"},{"name":"windows","slug":"os/windows","permalink":"http://noritersand.github.io/categories/os/windows/"}],"tags":[{"name":"todo","slug":"todo","permalink":"http://noritersand.github.io/tags/todo/"},{"name":"shell","slug":"shell","permalink":"http://noritersand.github.io/tags/shell/"},{"name":"windows","slug":"windows","permalink":"http://noritersand.github.io/tags/windows/"},{"name":"cmd","slug":"cmd","permalink":"http://noritersand.github.io/tags/cmd/"},{"name":"powershell","slug":"powershell","permalink":"http://noritersand.github.io/tags/powershell/"}]},{"title":"윈도우10: 단축키 모음","slug":"윈도우10-단축키-모음","date":"2018-03-19T06:24:11.000Z","updated":"2018-07-11T00:15:13.214Z","comments":true,"path":"os/windows/윈도우10-단축키-모음/","link":"","permalink":"http://noritersand.github.io/os/windows/윈도우10-단축키-모음/","excerpt":"","text":"전역 단축키 WIN + A: 알림 센터 열기 WIN + B: 트레이 아이콘 선택 WIN + D: 바탕화면 보기 - 다시 WIN + D를 누르면 이전 상태로 돌아온다 WIN + E: 윈도우 탐색기(내 PC) 실행 WIN + G: 게임 표시줄 열기. 화면 캡처 혹은 녹화 등의 기능을 제공 WIN + I: Metro 설정 열기 WIN + K: 연결(무선 디스플레이 및 오디오) WIN + L: 컴퓨터 잠금. 비밀번호 입력 화면으로 바뀜. WIN + M: 모든 창 최소화 - WIN + SHIFT + M을 누르면 이전 상태로 돌아옴 WIN + P: 프로젝트. 다중 화면 설정 WIN + R: 실행창 열기 WIN + S: 윈도우 검색. 앱, 파일 등을 찾을 수 있음 WIN + T: 작업 표시줄 단추 선택. 실행 중인 창을 선택 WIN + W: windows Ink 열기 WIN + X: 시작 메뉴 열기 WIN + PrtSc: 화면 캡처 후 파일로 저장 WIN + Pause: 시스템 정보 창 열기 WIN + +/-/=: 돋보기 실행(확대/축소) WIN + Enter: 내레이터 설정 WIN + 방향키: 창 위치/크기 WIN + SHIFT + ↑: 현재 창 수직 최대화 WIN + SHIFT + ←,→: 현재 창 이전/다음 모니터로 이동 WIN + 숫자키: 작업 표시줄에 있는 프로그램 실행 혹은 활성화 WIN + SHIFT + 숫자키: 작업 표시줄에 있는 프로그램 실행 WIN + Ctrl + C: 흑백/컬러 전환 Ctrl + SHIFT + ESC: 작업 관리자 실행 Alt + PrtSc: 화면 캡처 후 클립보드에 저장 SHIFT + F10: 마우스 우클릭 탐색기 단축키 ALT + LEFT ARROW: 뒤로 ALT + RIGHT ARROW: 앞으로 ALT + UP ARROW: 위로 CTRL + MOUSEWHEEL: 보기변경 CTRL + SHIFT + N: 새폴더 스티커메모 단축키 CTRL + B, I, U: 굵게, 이탤릭, 밑줄 CTRL + T: 취소선 CTRL + SHIFT + &gt;: 폰트크게 CTRL + SHIFT + &lt;: 폰트작게","categories":[{"name":"os","slug":"os","permalink":"http://noritersand.github.io/categories/os/"},{"name":"windows","slug":"os/windows","permalink":"http://noritersand.github.io/categories/os/windows/"}],"tags":[{"name":"windows","slug":"windows","permalink":"http://noritersand.github.io/tags/windows/"},{"name":"shortcut","slug":"shortcut","permalink":"http://noritersand.github.io/tags/shortcut/"},{"name":"hotkey","slug":"hotkey","permalink":"http://noritersand.github.io/tags/hotkey/"}]},{"title":"윈도우: 쉘 명령어 windows shell commands","slug":"윈도우-쉘-명령어-windows-shell-commands","date":"2018-03-15T04:46:15.000Z","updated":"2018-07-11T00:15:13.213Z","comments":true,"path":"os/windows/윈도우-쉘-명령어-windows-shell-commands/","link":"","permalink":"http://noritersand.github.io/os/windows/윈도우-쉘-명령어-windows-shell-commands/","excerpt":"","text":"netstatnetstat -nao # PID와 함께 모든 연결과 수신대기 포트를 숫자형식으로 출력하되netstat -nao | findstr '8081' # '8081'로 필터링 tasklisttasklist | findstr '18292' # 프로세스 목록을 출력하되 '18292'로 필터링 taskkilltaskkill /f /pid 5888 # PID가 5888인 프로세스 중지","categories":[{"name":"os","slug":"os","permalink":"http://noritersand.github.io/categories/os/"},{"name":"windows","slug":"os/windows","permalink":"http://noritersand.github.io/categories/os/windows/"}],"tags":[{"name":"todo","slug":"todo","permalink":"http://noritersand.github.io/tags/todo/"},{"name":"shell","slug":"shell","permalink":"http://noritersand.github.io/tags/shell/"},{"name":"windows","slug":"windows","permalink":"http://noritersand.github.io/tags/windows/"},{"name":"cmd","slug":"cmd","permalink":"http://noritersand.github.io/tags/cmd/"}]},{"title":"윈도우10: 시작화면 앱 실행 바로가기 추가하는 방법.","slug":"윈도우10-시작화면-앱-실행-바로가기-추가하는-방법","date":"2018-03-15T04:22:25.000Z","updated":"2018-07-11T00:15:13.214Z","comments":true,"path":"os/windows/윈도우10-시작화면-앱-실행-바로가기-추가하는-방법/","link":"","permalink":"http://noritersand.github.io/os/windows/윈도우10-시작화면-앱-실행-바로가기-추가하는-방법/","excerpt":"","text":"윈도우 인스톨러로 설치한 앱일 때윈도우 검색(윈도우키+S) 후 [우클릭] - [시작 화면에 고정] 실행파일만 있는 앱일 때톰캣이나 이클립스 패키지 버전(압축 버전)처럼 설치 없이 바로 실행할 수 있는 앱일 때,우선 사용자폴더\\AppData\\Roaming\\Microsoft\\Windows\\Start Menu\\Programs에 실행파일의 바로가기를 추가한다. 그리고 추가한 바로가기는 윈도우 검색으로 검색할 수 있으니 검색 후 [우클릭] - [시작 화면에 고정] 하면 된다. 관련 폴더로 C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs가 있다.","categories":[{"name":"os","slug":"os","permalink":"http://noritersand.github.io/categories/os/"},{"name":"windows","slug":"os/windows","permalink":"http://noritersand.github.io/categories/os/windows/"}],"tags":[{"name":"windows","slug":"windows","permalink":"http://noritersand.github.io/tags/windows/"}]},{"title":"JavaScript: 정규식 모음","slug":"JavaScript-정규식-모음","date":"2018-03-09T08:53:21.000Z","updated":"2018-07-11T00:15:13.200Z","comments":true,"path":"javascript/JavaScript-정규식-모음/","link":"","permalink":"http://noritersand.github.io/javascript/JavaScript-정규식-모음/","excerpt":"","text":"숫자 - 통화 변환'1000000'.replace(/(\\d)(?=(\\d&#123;3&#125;)+(?!\\d))/g, '$1,'); 통화 - 숫자 변환 #1'1,000,000'.replace(/[^0-9]/g, ''); 통화 - 숫자 변환 #2'123,123,123'.replace(/\\,/g, '');","categories":[{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/categories/javascript/"}],"tags":[{"name":"regex","slug":"regex","permalink":"http://noritersand.github.io/tags/regex/"},{"name":"ecmascript","slug":"ecmascript","permalink":"http://noritersand.github.io/tags/ecmascript/"},{"name":"javascript","slug":"javascript","permalink":"http://noritersand.github.io/tags/javascript/"}]},{"title":"Maven: 메이븐 넥서스에 jar 업로드 하기","slug":"Maven-메이븐-넥서스에-jar-업로드-하기","date":"2018-02-22T04:58:28.000Z","updated":"2018-07-11T00:15:13.205Z","comments":true,"path":"buildsystem/Maven-메이븐-넥서스에-jar-업로드-하기/","link":"","permalink":"http://noritersand.github.io/buildsystem/Maven-메이븐-넥서스에-jar-업로드-하기/","excerpt":"","text":"https://support.sonatype.com/hc/en-us/articles/213465818-How-can-I-programmatically-upload-an-artifact-into-Nexus-2-","categories":[{"name":"buildsystem","slug":"buildsystem","permalink":"http://noritersand.github.io/categories/buildsystem/"}],"tags":[{"name":"buildsystem","slug":"buildsystem","permalink":"http://noritersand.github.io/tags/buildsystem/"},{"name":"maven","slug":"maven","permalink":"http://noritersand.github.io/tags/maven/"},{"name":"nexus","slug":"nexus","permalink":"http://noritersand.github.io/tags/nexus/"},{"name":"link post","slug":"link-post","permalink":"http://noritersand.github.io/tags/link-post/"}]},{"title":"Git: 레퍼런스란?","slug":"Git-레퍼런스란","date":"2018-02-07T04:19:55.000Z","updated":"2018-07-11T00:15:13.186Z","comments":true,"path":"git/Git-레퍼런스란/","link":"","permalink":"http://noritersand.github.io/git/Git-레퍼런스란/","excerpt":"","text":"레퍼런스란 커밋 체크섬을 이름으로 사용할 수 있도록 관리되는 파일 시스템이다.예를 들어 master라는 브랜치는 사실 특정 커밋을 가리키는 포인터인데, 이 포인터가 어느 커밋을 가리키는지를 알 수 있도록 master라는 파일에 해당 커밋의 체크섬을 저장한다.$ git checkout masterSwitched to branch 'master'Your branch is up to date with 'origin/master'.$ git show HEADcommit f38273c9ecbea5a009667316425883a556f9ca47 (HEAD -&gt; master, origin/master, origin/HEAD)$ cat .git/refs/heads/masterf38273c9ecbea5a009667316425883a556f9ca47 .git/refs/heads/master 파일을 열어보면 master 브랜치의 마지막 커밋에 해당하는 체크섬이 저장되어 있는걸 확인할 수 있다.","categories":[{"name":"git","slug":"git","permalink":"http://noritersand.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://noritersand.github.io/tags/git/"},{"name":"reference","slug":"reference","permalink":"http://noritersand.github.io/tags/reference/"}]},{"title":"Gist를 이용한 소스 관리","slug":"Gist를-이용한-소스-관리-링크","date":"2018-02-07T02:21:27.000Z","updated":"2018-07-11T00:15:13.186Z","comments":true,"path":"git/Gist를-이용한-소스-관리-링크/","link":"","permalink":"http://noritersand.github.io/git/Gist를-이용한-소스-관리-링크/","excerpt":"","text":"https://gist.github.com/safe1981/2041116","categories":[{"name":"git","slug":"git","permalink":"http://noritersand.github.io/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://noritersand.github.io/tags/git/"},{"name":"gist","slug":"gist","permalink":"http://noritersand.github.io/tags/gist/"}]},{"title":"eclipse: WST와 JST","slug":"eclipse-WST와-JST","date":"2018-02-07T02:10:53.000Z","updated":"2018-07-11T00:15:13.206Z","comments":true,"path":"tools/eclipse-WST와-JST/","link":"","permalink":"http://noritersand.github.io/tools/eclipse-WST와-JST/","excerpt":"","text":"WST Link Stands for web standard tools provides support for building multi-tier Web applications The server component contains the Server Tools framework and adapters for selected servers. At the WST level, the server component is a very generic infrastructure. JST Link Stands for j2ee Standard Tools provides support for building multi-tier J2EE applications The server component contains the J2EE Server Tools framework and adapters for selected popular J2EE servers such as Apache Tomcat. 출처: https://stackoverflow.com/questions/21027578/what-are-jst-and-wst-server-adapters","categories":[{"name":"tools","slug":"tools","permalink":"http://noritersand.github.io/categories/tools/"}],"tags":[{"name":"eclipse","slug":"eclipse","permalink":"http://noritersand.github.io/tags/eclipse/"},{"name":"plugin","slug":"plugin","permalink":"http://noritersand.github.io/tags/plugin/"},{"name":"wst","slug":"wst","permalink":"http://noritersand.github.io/tags/wst/"},{"name":"jst","slug":"jst","permalink":"http://noritersand.github.io/tags/jst/"}]},{"title":"github.io 작성 툴 jekyll, hexo","slug":"github-io-작성-툴-jekyll-hexo","date":"2018-02-07T02:07:58.000Z","updated":"2018-07-11T00:15:13.209Z","comments":true,"path":"web/github-io-작성-툴-jekyll-hexo/","link":"","permalink":"http://noritersand.github.io/web/github-io-작성-툴-jekyll-hexo/","excerpt":"","text":"참고한 글 https://jekyllrb.com https://hexo.io this란 무엇인가블라블라","categories":[{"name":"web","slug":"web","permalink":"http://noritersand.github.io/categories/web/"}],"tags":[{"name":"git","slug":"git","permalink":"http://noritersand.github.io/tags/git/"},{"name":"jekyll","slug":"jekyll","permalink":"http://noritersand.github.io/tags/jekyll/"},{"name":"hexo","slug":"hexo","permalink":"http://noritersand.github.io/tags/hexo/"},{"name":"github","slug":"github","permalink":"http://noritersand.github.io/tags/github/"}]},{"title":"프로시저 호출방법","slug":"프로시저-호출방법","date":"2018-02-05T06:25:02.000Z","updated":"2018-07-11T00:15:13.216Z","comments":true,"path":"dbms/oracle/프로시저-호출방법/","link":"","permalink":"http://noritersand.github.io/dbms/oracle/프로시저-호출방법/","excerpt":"","text":"이런 프로시저가 있을 때:CREATE OR REPLACE PROCEDURE TEST_PROCEDURE_01( PARAMETER1 IN VARCHAR2, RESULT OUT VARCHAR2)ASBEGIN RESULT := 'BEGIN'; DBMS_OUTPUT.PUT_LINE(PARAMETER1); RESULT := 'END';END;/ 아래처럼 호출하면:DECLARE RESULT VARCHAR2(100);BEGIN TEST_PROCEDURE_BY_NORITER('hello!', RESULT); DBMS_OUTPUT.PUT_LINE(RESULT);END;COMMIT; 요로코롬 찍힌다:hello!END 끗.","categories":[{"name":"dbms","slug":"dbms","permalink":"http://noritersand.github.io/categories/dbms/"},{"name":"oracle","slug":"dbms/oracle","permalink":"http://noritersand.github.io/categories/dbms/oracle/"}],"tags":[{"name":"dbms","slug":"dbms","permalink":"http://noritersand.github.io/tags/dbms/"},{"name":"sql","slug":"sql","permalink":"http://noritersand.github.io/tags/sql/"},{"name":"oracle","slug":"oracle","permalink":"http://noritersand.github.io/tags/oracle/"}]},{"title":"윈도우: 원격 데스크톱 연결 시 \"내부 오류가 발생했습니다.\"","slug":"윈도우-원격-데스크톱-연결-시-내부-오류가-발생했습니다","date":"2018-01-26T08:49:59.000Z","updated":"2018-07-11T00:15:13.213Z","comments":true,"path":"os/windows/윈도우-원격-데스크톱-연결-시-내부-오류가-발생했습니다/","link":"","permalink":"http://noritersand.github.io/os/windows/윈도우-원격-데스크톱-연결-시-내부-오류가-발생했습니다/","excerpt":"","text":"참고한 글 http://www.dsun.kr/78 위와 같은 경고창이 나타나고 연결이 안되는 경우엔, 매우 높은 확률로 방화벽 장비에서 윈도우 원격 접속 기본 포트인 3389를 차단하고 있을 가능성이 크다. 이 때는 차단 중인 포트를 다른 번호로 변경해야 하는데 방법은, 우선 원격으로 접속 당할(?) 컴퓨터에서레지스트리: HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\Wds\\rdpwd\\Tds\\tcp\\PortNumber HKEY_LOCAL_MACHINE\\SYSTEM\\CurrentControlSet\\Control\\Terminal Server\\WinStations\\RDP-Tcp\\PortNumber 를 3389에서 원하는 포트로 변경 후 윈도우 방화벽 인바운드 규칙(1에서 변경한 포트로)을 생성 후 재시작한다. 원격으로 접속하는 쪽에서는 123.123.123.123:9093 처럼 세미콜론과 함께 포트를 명시하면 끝.","categories":[{"name":"os","slug":"os","permalink":"http://noritersand.github.io/categories/os/"},{"name":"windows","slug":"os/windows","permalink":"http://noritersand.github.io/categories/os/windows/"}],"tags":[{"name":"windows","slug":"windows","permalink":"http://noritersand.github.io/tags/windows/"},{"name":"debugging log","slug":"debugging-log","permalink":"http://noritersand.github.io/tags/debugging-log/"},{"name":"remote desktop","slug":"remote-desktop","permalink":"http://noritersand.github.io/tags/remote-desktop/"}]}]}